package пакМодули

import (
	мФмт "fmt"
	"oc/internal/types"
)

/*
	Модуль предоставляет тип для описателя модулей.
	Потом ссылки на объекты этого типа хранятся в общем словаре глобального объекта модулей.
	Тип является частным и не экспортируется из пакета
*/

//ИМодульОпис -- интерфейс к описателю модуля
type ИМодульОпис interface {
	Имя() СМодульИмя //возвращает хранимое имя модуля
}

//Описатель модуля
type тМодульОпис struct {
	путь  types.UWord //путь к модулю устанавливается один раз только при создании
	алиас types.IWord //алиас модуля устанавливается один раз только при создании
}

//Возвращает ссылку на новый тМодульОпис
func _МодульОписНов(пАлиас types.IWord, пПуть types.UWord) (модуль *тМодульОпис, ош error) {
	модуль = &тМодульОпис{}
	if модуль == nil {
		return nil, мФмт.Errorf("_МодульОписНов(): нет памяти на новый описатель модуля?\n")
	}
	if ош = модуль._АлиасУст(пАлиас); ош != nil {
		return nil, мФмт.Errorf("_МодульОписНов(): ошибка при установке имени описателя модуля\n\t%v", ош)
	}
	модуль.путь = пПуть //путь к модулю может быть пустым
	return модуль, nil
}

//Имя -- возвращает хранимое имя модуля
func (сам *тМодульОпис) Имя() types.СМодульИмя {
	if len(сам.путь) != 0 {
		return types.СМодульИмя(сам.путь)
	}
	return types.СМодульИмя(сам.алиас.Слово())
}

func (сам *тМодульОпис) _АлиасУст(пАлиас types.IWord) (ош error) {
	//Убедиться, что имя модуля допустимо
	if !пАлиас.IsName() {
		return мФмт.Errorf("тМодульОпис._ИмяУст(): пИмя=[%v] не является строгим именем алиаса\n", пАлиас.Слово())
	}
	сам.алиас = пАлиас
	return nil
}
