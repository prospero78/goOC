package пакСекцияКоммент

/*
	Модуль предоставляет тип секции комментариев.
	На самом деле -- такой не существует, но при анализе опций компилятора -- может оказаться полезным
*/

import (
	мСлово "../../пакСлово"
	мСек "../пакСекция"
	мФмт "fmt"
)

//ИСекцияКоммент -- интерфейс к псевдосекции комментариев
type ИСекцияКоммент interface {
	мСек.ИСекция
	//Обработать() error      //Нужно ли это -- под сомнением
	СловоДоб(мСлово.IWord) //Нужно для добавления слов за концом модуля
}

//тСекцияКоммент -- тип псевдосекции со словами комментария
type тСекцияКоммент struct {
	слова    map[мСек.UWordNum]мСлово.IWord
	словаВсе map[мСек.UWordNum]мСлово.IWord
	класс    мСек.СКласс
}

//СекцияКомментНов -- возвращает новый экземпляр типа псевдосекции комментариев
func СекцияКомментНов() (коммент ИСекцияКоммент, ош error) {
	_секция := &тСекцияКоммент{}
	if _секция == nil {
		return nil, мФмт.Errorf("СекцияКомментНов(): нет памяти на секцию комментариев?\n")
	}

	_секция.слова = make(map[мСек.UWordNum]мСлово.IWord)
	return _секция, nil
}

//Возвращает класс секции (МОДУЛЬ, ИМПОРТ, КОММЕНТ и т.д.)
func (сам *тСекцияКоммент) Класс() мСек.СКласс {
	return сам.класс
}

// СловаКоммент -- Возвращает слова импорта
func (сам *тСекцияКоммент) Слова() (слова map[мСек.UWordNum]мСлово.IWord) {
	return сам.слова
}

// СловаУст -- устанавливает список слов секции
func (сам *тСекцияКоммент) СловаУст(пСлова map[мСек.UWordNum]мСлово.IWord) error {
	if пСлова == nil {
		return мФмт.Errorf("ТСекияя.словаУст(): пСлова не может быть nil\n")
	}
	сам.словаВсе = пСлова
	return nil
}

//СловоДоб -- добавляет слово в секцию комментариев. Вызывается, когда
//за окончанием модуля есть текст. Может быть полезно
func (сам *тСекцияКоммент) СловоДоб(пСлово мСлово.IWord) {
	сам.слова[мСек.UWordNum(len(сам.слова))] = пСлово
}

//Обработать -- главный обработчик секции
func (сам *тСекцияКоммент) _Обработать() (ош error) {
	цУровень := 0
	спрКоммент := make(map[мСек.UWordNum]мСлово.IWord)
	спрМодуль := make(map[мСек.UWordNum]мСлово.IWord)
	адрМодуль := мСек.UWordNum(0)
	адрКоммент := мСек.UWordNum(0)
	цНомерМодуль := мСек.UWordNum(0)
	for цНомерМодуль = 0; int(цНомерМодуль) < len(сам.СловаДругие()); цНомерМодуль++ {
		слово := сам.СловаДругие()[цНомерМодуль]
		//пакКонс.Конс.Отладить("Слово: " + слово.Строка())
		стрСлово := слово.Слово()
		if стрСлово == "(*" {
			цУровень++
			continue
			//пакКонс.Конс.Отладить("Уровень комментов: " + мФмт.Sprintf("%v", цУровень))
		} else if стрСлово == "*)" {
			цУровень--
			continue
		}
		//Заполнение словарей в зависимости от уровня комментариев
		if цУровень == 0 {
			спрМодуль[адрМодуль] = слово
			адрМодуль++
		} else {
			спрКоммент[адрКоммент] = слово
			адрКоммент++
		}
	}
	if цУровень != 0 {
		return мФмт.Errorf("ТуКоммент.Обработать(): уровень комментариев на сбалансирован, уровень = %v", цУровень)
	}
	//мКонс.Конс.Отладить(мФмт.Sprintf("Итоговый уровень комментов > [%v].   Всего слов > [%v].", цУровень, len(спрКоммент)))
	//мКонс.Конс.Отладить(мФмт.Sprintf("Слов модуля: %v   Всего слов в модуле: %v", len(спрМодуль), len(спрКоммент)+len(спрМодуль)))
	сам.слова = спрКоммент
	сам.словаВсе = спрМодуль
	return nil
}

func (сам *тСекцияКоммент) СловаДругие() map[мСек.UWordNum]мСлово.IWord {
	return сам.словаВсе
}
