package пакСекция

/*
	Вынос основы секции в отдельный тип.
	У секции есть свой класс, но нет специального имени
*/

import (
	мКлючи "../../пакКлючи"
	мСлово "../../пакСлово"
	мФмт "fmt"
)

//СКласс -- специальный строковый тип для хранения класса секции
type СКласс string

//UWordNum -- специальный целочисленный тип для хранения номера слова секции
type UWordNum int

//ИСекция -- базовый тип секции
type ИСекция interface {
	Слова() map[UWordNum]мСлово.IWord
	СловаУст(map[UWordNum]мСлово.IWord) error
	Класс() СКласс
}

//тСекция -- базовый тип для всех секций
type тСекция struct {
	слова    map[UWordNum]мСлово.IWord
	словаВсе map[UWordNum]мСлово.IWord
	класс    СКласс //Хранит класс секциии
}

//СекцияНов -- создаёт и возвращает новый объект типа секции
func СекцияНов(пКласс СКласс) (секция ИСекция, ош error) {
	_секция := &тСекция{}
	if _секция == nil {
		return nil, мФмт.Errorf("СекцияНов(): нет памяти под новую секцию?\n")
	}
	if ош = _секция._КлассУст(пКласс); ош != nil {
		return nil, мФмт.Errorf("СекцияНов(): ошибка при установке класса секции\n\t%v", ош)
	}
	_секция.словаВсе = make(map[UWordNum]мСлово.IWord)
	return _секция, nil
}

// Слова -- возвращает список слов модуля
func (сам *тСекция) Слова() map[UWordNum]мСлово.IWord {
	return сам.слова
}

//Устанавливает класс секции в модуле. Вызывается один раз
func (сам *тСекция) _КлассУст(пКласс СКласс) (ош error) {
	if сам.класс != "" {
		return мФмт.Errorf("тСекция._КлассУст(): класс секции уже установлен. тип=[%v], пКласс=[%v]\n", сам.класс, пКласс)
	}
	if пКласс == "" {
		return мФмт.Errorf("тСекция._КлассУст(): класс секции не может быть пустым, пКласс=[%v]\n", пКласс)
	}
	if ош = мКлючи.Ключи.СекцияТипПров(мКлючи.СКлюч(пКласс)); ош != nil {
		return мФмт.Errorf("тСекция._КлассУст(): ошибка при проверке класса секции(%v)\n\t%v", пКласс, ош)
	}
	return nil
}

// СловаУст -- устанавливает список слов секции
func (сам *тСекция) СловаУст(пСлова map[UWordNum]мСлово.IWord) error {
	if пСлова == nil {
		return мФмт.Errorf("ТСекияя.словаУст(): пСлова не может быть nil\n")
	}
	сам.словаВсе = пСлова
	return nil
}

//Возвращает класс секции (МОДУЛЬ, ИМПОРТ, КОММЕНТ и т.д.)
func (сам *тСекция) Класс() СКласс {
	return сам.класс
}

//СловаОбрезать -- обрезает слова в секции
func СловаОбрезать(пСлова map[UWordNum]мСлово.IWord) (map[UWordNum]мСлово.IWord, error) {
	if len(пСлова) == 0 {
		return nil, мФмт.Errorf("СловаОбрезать(): справочник слов не может быть пустым\n")
	}
	адр := UWordNum(1)
	for адр = 1; int(адр) < len(пСлова); адр++ {
		пСлова[адр-1] = пСлова[адр]
	}
	delete(пСлова, UWordNum(len(пСлова))-1)
	return пСлова, nil
}
