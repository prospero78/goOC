package litera

/*
	Модуль предоставляет потокобезопасный тип для работы с отдельной литерой.
*/

import (
	"fmt"
	мТип "oc/internal/types"
	"strings"
)

//ТЛит -- тип для работы с отдельной литерой
type ТЛит struct {
	лит   мТип.ULit
	класс мТип.ULitКласс //Хранит класс литеры
}

const (
	//наборы букв для перебора
	стрБуквыРус = "абвгдеёжзийклмнопрстуфхцчшщьыъэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯ"
	стрБуквыАнг = "abcdefghjiklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	стрБуквыВсе = стрБуквыРус + стрБуквыАнг

	//CтрЦифры -- список цифр, что могут встречаться в числах
	стрЦифры = "0123456789."

	//Различные специальные литеры, не имеющие смысла в коде
	стрСпецЛит = "`~!@#№$%^&?\\_"
	//Литеры-разделители
	стрРазделЛит = "\n\t "
	//Литеры-скобки
	стрЛитСкобки = "(){}[]"
	//Литеры-операции
	стрЛитОпер                = "*/+-"
	КБуква     мТип.ULitКласс = iota + 1
	КСпецЛит
	КЦифра
	КРазделит
	КСкобки
	КОперации
)

//Нов -- возвращает ссылку на новый ТЛит
func Нов(пЛит мТип.ULit) (лит *ТЛит, ош error) {
	_лит := ТЛит{}
	if ош = _лит.Уст(пЛит); ош != nil {
		return nil, fmt.Errorf("litera.go/Нов(): ERROR при установке литеры(%v)\n\t%v", пЛит, ош)
	}
	return &_лит, nil
}

// IsLetter -- проверяет наличие буквы в литере
func (сам *ТЛит) IsLetter() bool {
	return сам.класс == КБуква
}

// IsSpecLetter -- проверяет наличие специальных литер не имеющих смысла в коде
func (сам *ТЛит) IsSpecLetter() bool {
	return сам.класс == КСпецЛит
}

//IsDigit -- проверяет, что литера цифра
func (сам *ТЛит) IsDigit() bool {
	return сам.класс == КЦифра
}

//ЕслиРаделит -- проверяет, что литера разделитель
func (сам *ТЛит) ЕслиРазделит() bool {
	return сам.класс == КРазделит
}

//ЕслиСкобки -- проверяет, что литера скобка
func (сам *ТЛит) ЕслиСкобки() bool {
	return сам.класс == КСкобки
}

//ЕслиОпер -- проверяет, что литера операция
func (сам *ТЛит) ЕслиОпер() bool {
	return сам.класс == КОперации
}

//Уст -- устанавливает хранимую литеру
func (сам *ТЛит) Уст(пЛит мТип.ULit) error {
	if пЛит == "" {
		return fmt.Errorf("ТЛит.Уст(): пЛит не может быть пустой\n")
	}
	if strings.Contains(стрБуквыВсе, string(пЛит)) {
		сам.класс = КБуква
	} else if strings.Contains(стрСпецЛит, string(пЛит)) {
		сам.класс = КСпецЛит
	} else if strings.Contains(стрЦифры, string(пЛит)) {
		сам.класс = КЦифра
	} else if strings.Contains(стрРазделЛит, string(пЛит)) {
		сам.класс = КРазделит
	} else if strings.Contains(стрЛитСкобки, string(пЛит)) {
		сам.класс = КСкобки
	} else if strings.Contains(стрЛитОпер, string(пЛит)) {
		сам.класс = КОперации
	} else {
		return fmt.Errorf("ТЛит.Уст(): ERROR неизвестный класс литеры, пЛит=[%v]\n", пЛит)
	}
	сам.лит = пЛит
	return nil
}

//Получ -- возвращает хранимую литеру
func (сам *ТЛит) Получ() мТип.ULit {
	return сам.лит
}

//Класс -- возвращает класс литеры
func (сам *ТЛит) Класс() мТип.ULitКласс {
	return сам.класс
}

func (сам *ТЛит) String() string {
	return string(сам.лит)
}
