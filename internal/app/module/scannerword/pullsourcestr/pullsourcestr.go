package pullsourcestr

/*
	Пакет предоставляет тип, который хранит построчно исходник.
	К строке можно обратиться по номеру, или полностью получить пул строк
*/

import (
	"fmt"
	мИс "oc/internal/app/module/scannerword/pullsourcestr/sourcestr"
	//мЛог "oc/internal/log"
	мЛог "oc/internal/log"
	мТип "oc/internal/types"
	мСтр "strings"
)

//ТПулСтроки -- тип хранит список исходных строк
type ТПулСтроки struct {
	пулСтроки map[int]мТип.ИСтрокаИсх
	лог       *мЛог.ТЛог
}

//ПулИсхСтрокиНов -- возвращает новую ссылку на ИПулИсхСтроки
func Нов(текстИсх мТип.СТекстИсх, режим int) (исх *ТПулСтроки) {
	_исх := ТПулСтроки{
		лог:       мЛог.Нов("ТПулСтроки", режим),
		пулСтроки: make(map[int]мТип.ИСтрокаИсх),
	}
	_исх._НаСтрокиРазбить(текстИсх)
	return &_исх
}

//НаСтрокиРазбить -- разбивает на строки содержимое строки
func (сам *ТПулСтроки) _НаСтрокиРазбить(пИсх мТип.СТекстИсх) {
	пулСтроки := мСтр.Split(string(пИсх), "\n")

	for ном, стр := range пулСтроки {
		исхСтрока, _ := мИс.Нов(мТип.ССтрокаНом(ном+1), мТип.ССтрокаИсх(стр))
		сам.пулСтроки[len(сам.пулСтроки)+1] = исхСтрока
	}
	сам.лог.Отладка("_НаСтрокиРазбить", "всего строк: ", len(пулСтроки))
}

//Строка -- возвращает строку по указанному номеру
func (сам *ТПулСтроки) Строка(пНомер мТип.ССтрокаНом) (стр мТип.ИСтрокаИсх, ош error) {
	стр, ок := сам.пулСтроки[int(пНомер)]
	if !ок {
		return nil, fmt.Errorf("ТПулСтроки.Строка(): строки с номером [%v] не существует\n", пНомер)
	}
	return стр, nil
}

func (сам *ТПулСтроки) СтрокиВсе() map[int]мТип.ИСтрокаИсх {
	return сам.пулСтроки
}
