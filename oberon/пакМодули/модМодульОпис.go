package пакМодули

/*
	Модуль предоставляет тип для описателя модулей.
	Потом ссылки на объекты этого типа хранятся в общем словаре глобального объекта модулей.
	Тип является частным и не экспортируется из пакета
*/
import (
	мИнт "../пакИнтерфейсы"
	мФмт "fmt"
)

//ИМодульОпис -- интерфейс к описателю модуля
type ИМодульОпис interface {
	Имя() СМодульИмя //возвращает хранимое имя модуля
}

//Описатель модуля
type тМодульОпис struct {
	путь  мИнт.ССлово //путь к модулю устанавливается один раз только при создании
	алиас мИнт.ИСлово //алиас модуля устанавливается один раз только при создании
}

//Возвращает ссылку на новый тМодульОпис
func _МодульОписНов(пАлиас мИнт.ИСлово, пПуть мИнт.ССлово) (модуль *тМодульОпис, ош error) {
	модуль = &тМодульОпис{}
	if модуль == nil {
		return nil, мФмт.Errorf("_МодульОписНов(): нет памяти на новый описатель модуля?\n")
	}
	if ош = модуль._АлиасУст(пАлиас); ош != nil {
		return nil, мФмт.Errorf("_МодульОписНов(): ошибка при установке имени описателя модуля\n\t%v", ош)
	}
	модуль.путь = пПуть //путь к модулю может быть пустым
	return модуль, nil
}

//Имя -- возвращает хранимое имя модуля
func (сам *тМодульОпис) Имя() мИнт.СМодульИмя {
	if len(сам.путь) != 0 {
		return мИнт.СМодульИмя(сам.путь)
	}
	return мИнт.СМодульИмя(сам.алиас.Слово())
}

func (сам *тМодульОпис) _АлиасУст(пАлиас мИнт.ИСлово) (ош error) {
	//Убедиться, что имя модуля допустимо
	if !пАлиас.ЕслиИмяСтрого() {
		return мФмт.Errorf("тМодульОпис._ИмяУст(): пИмя=[%v] не является строгим именем алиаса\n", пАлиас.Слово())
	}
	сам.алиас = пАлиас
	return nil
}
