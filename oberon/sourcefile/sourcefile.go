package sourcefile

/*
	Модуль предоставляет тип для чтения файла и записи его же.
*/

import (
	мКонс "../пакКонсоль"
	мФмт "fmt"
	мВв "io/ioutil"
)

//ТИсхФайл -- тип для работы с исходным файлом
type ТИсхФайл struct {
	размер int //Размер исходника в рунах
	текст  string
}

//ИсхФайлНов -- возвращает ссылку на новый ТИсхФайл
func ИсхФайлНов(пИмяФайла string) (файл *ТИсхФайл) {
	if пИмяФайла == "" {
		panic(мФмт.Errorf("ИсхФайлНов(): ФАТАЛЬНЫЙ СБОЙ пИмяФайла не может быть пустым\n"))
	}
	_файл := ТИсхФайл{}
	_файл._Считать(пИмяФайла)
	return &_файл
}

//_Считать -- читает исходный файл
func (сам *ТИсхФайл) _Считать(пИмяФайла string) (ош error) {
	мКонс.Конс.Отладить("ТИсхФайл.Считать()")
	байты, ош := мВв.ReadFile(пИмяФайла)
	if ош != nil {
		return мФмт.Errorf("ТИсхФайл.Считать(): ошибки при попытке прочитать файл\n\t%v", ош)
	}

	// Строковое представление байтов
	сам.текст = string(байты)

	сам.размер = len([]rune(сам.текст))
	//мФмт.Printf("Текст:\n%v\nДлина: %v\n", сам.текст, сам.размер)
	return nil
}

//Лит -- Возвращает литеру по номеру руны
func (сам *ТИсхФайл) Лит(пПоз int) (лит string) {
	if пПоз < 0 {
		panic(мФмт.Errorf("ТИсхФайл.Лит(): указатель литеры пПоз не может быть < 0\n"))
	}
	if пПоз > сам.размер-1 {
		panic(мФмт.Errorf("ТИсхФайл.Лит(): указатель литеры пПоз больше последней литеры, пПоз=%v, размер=[%v]\n", пПоз, сам.размер))
	}
	текст := []rune(сам.текст)
	лит = string(текст[пПоз])
	return лит
}

//Исходник -- возвращает полностью исходный текст в отдельном срезе рун
func (сам *ТИсхФайл) Исходник() (текст string) {
	return сам.текст
}

//Печать -- печатает исходный файл
func (сам *ТИсхФайл) Печать() {
	мКонс.Конс.Печать(string(сам.текст))
}

//Размер -- возвращает размер исходника в рунах
func (сам *ТИсхФайл) Размер() int {
	return сам.размер
}
