package sourcefile

/*
	Модуль предоставляет тип для чтения файла и записи его же.
*/

import (
	мФмт "fmt"
	мВв "io/ioutil"

	мКонс "../пакКонсоль"
	мЛит "../liter"
	мСп "../stringpos"
)

//СФайлИсхИмя -- специальный строковый тип для имени файла исходника
type СФайлИсхИмя string

//СИсхТекст -- специальный строковый тип для хранения исходного текста
type СИсхТекст string

//СИсхРазмер -- специальный целочисленный тип для хранения размера исходника
type СИсхРазмер int

//СИсхСтрока -- специальный строковый тип для хранения исходника строки
type СИсхСтрока string

//тИсхФайл -- тип для работы с исходным файлом
type тИсхФайл struct {
	размер СИсхРазмер //Размер исходника в рунах
	текст  СИсхТекст
}

//ИсхФайлНов -- возвращает ссылку на новый тИсхФайл
func ИсхФайлНов(пИмяФайла СФайлИсхИмя) (файл ИИсхФайл, ош error) {
	мКонс.Конс.Отладить("пакИсхФайл.Новый()")
	_файл := &тИсхФайл{}
	if _файл == nil {
		return nil, мФмт.Errorf("ИсхФайлНов(): нет памяти?\n")
	}
	if ош = _файл._Считать(пИмяФайла); ош != nil {
		return nil, мФмт.Errorf("ИсхФайлНов(): ОШИБКА при чтении исходного файла\n\t%v", ош)
	}
	return _файл, nil
}

//_Считать -- читает исходный файл
func (сам *тИсхФайл) _Считать(пИмяФайла СФайлИсхИмя) (ош error) {
	мКонс.Конс.Отладить("тИсхФайл.Считать()")
	if пИмяФайла == "" {
		пИмяФайла = "./Hello.o7"
	}
	байты, ош := мВв.ReadFile(string(пИмяФайла))
	if ош != nil {
		return мФмт.Errorf("тИсхФайл.Считать(): ошибки при попытке прочитать файл\n\t%v", ош)
	}

	// Строковое представление байтов
	сам.текст = СИсхТекст(string(байты))

	сам.размер = СИсхРазмер(len([]rune(сам.текст)))
	//мФмт.Printf("Текст:\n%v\nДлина: %v\n", сам.текст, сам.размер)
	return nil
}

//Лит -- Возвращает литеру по номеру руны
func (сам *тИсхФайл) Лит(пПоз мСп.ССтрПоз) (лит мЛит.СЛит, ош error) {
	if пПоз < 0 {
		return "", мФмт.Errorf("тИсхФайл.Лит(): указатель литеры пПоз не может быть < 0\n")
	}
	if СИсхРазмер(пПоз) > сам.размер-1 {
		return "", мФмт.Errorf("тИсхФайл.Лит(): указатель литеры пПоз больше последней литеры, пПоз=%v, размер=[%v]\n", пПоз, сам.размер)
	}
	текст := []rune(сам.текст)
	лит = мЛит.СЛит(string(текст[пПоз]))
	return лит, nil
}

//Исходник -- возвращает полностью исходный текст в отдельном срезе рун
func (сам *тИсхФайл) Исходник() (текст СИсхТекст) {
	return сам.текст
}

//Печать -- печатает исходный файл
func (сам *тИсхФайл) Печать() {
	мКонс.Конс.Печать(string(сам.текст))
}

//Размер -- возвращает размер исходника в рунах
func (сам *тИсхФайл) Размер() СИсхРазмер {
	return сам.размер
}
