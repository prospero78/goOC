package pullkeywords

/*
	Модуль предоставляет объект для хранения всех допустимых ключей в Обероне
	(в том числе и внациональной кодировке)
*/

import (
	мКлюч "./keyword"
	мФмт "fmt"
)

//тКлючиВсе -- тип для обработки всех допустимых ключей в Обероне
type тКлючиВсе struct {
	пул map[мКлюч.СКлюч]*мКлюч.ТКлюч
}

var (
	//Ключи -- объект для обработки всех допустимых ключей в Обероне
	Ключи *тКлючиВсе
)

func _КлючиВсеНов() {
	Ключи = &тКлючиВсе{
		пул: make(map[мКлюч.СКлюч]*мКлюч.ТКлюч),
	}
	if Ключи == nil {
		panic(мФмт.Sprintf("_КлючиВсеНов(): нет памяти под все ключи?\n"))
	}
}

func (сам *тКлючиВсе) _Доб(пКлюч мКлюч.СКлюч, пКлючи []мКлюч.СКлюч) {
	if len(пКлючи) == 0 {
		panic(мФмт.Sprintf("тКлючиВсе._Доб(): пКлюч не может иметь нулевую длину\n"))
	}
	ключ := мКлюч.КлючНов(пКлючи[0])
	for адр := 1; адр < len(пКлючи); адр++ {
		ключ.Доб(пКлючи[адр])
	}
	сам.пул[пКлюч] = ключ
}

/*СекцияТипПров -- проверяет, что переданный ключ реально является секцией
  Допустимые ключи:
  MODULE -- псевдосекция для модуля
  COMMENTDEF -- псевдосекция для комментариев
  IMPORT
  TYPE
  CONST
  VAR
  PROCDEF -- псевдосекция для процедур
  BEGIN -- секция инициализации модуля
*/
func (сам *тКлючиВсе) СекцияТипПров(пТип мКлюч.СКлюч) (ош error) {
	if пТип == "" {
		return мФмт.Errorf("тКлючиВсе.СекцияТипПров(): пКлюч не может иметь нулевую длину\n")
	}
	//Проверить, а существует ли такой ключ секции вообще
	for _, типСекции := range []string{"MODULE", "COMMENTDEF", "IMPORT", "TYPE", "CONST", "VAR", "PROCDEF", "BEGIN"} {
		//Проверить есть ли в базе синонимов такой тип секции
		синонимы := сам.пул[мКлюч.СКлюч(типСекции)]
		for _, тип := range синонимы.Синонимы() {
			if тип == пТип {
				return nil
			}
		}
	}
	return мФмт.Errorf("тКлючиВсе.СекцияТипПров(): в Обероне не может быть такого типа секции, пТип=[%v]\n", пТип)
}

func (сам *тКлючиВсе) Проверить(пКлюч, пСлово мКлюч.СКлюч) (ок bool, ош error) {
	if пКлюч == "" {
		return false, мФмт.Errorf("тКлючиВсе.Проверить(): пКлюч не может иметь нулевую длину\n")
	}
	//Проверить, а существует ли такой ключ вообще
	бЕсть := false
	for ключ := range сам.пул {
		if ключ == пКлюч {
			бЕсть = true
			break
		}
	}
	if !бЕсть {
		return false, мФмт.Errorf("тКлючиВсе.Проверить(): в Обероне не может быть такого ключа, пКлюч=[%v]\n", пКлюч)
	}
	//Проверить есть ли в базе синонимы
	синонимы := сам.пул[пКлюч]
	for _, ключ := range синонимы.Синонимы() {
		if ключ == пСлово {
			return true, nil
		}
	}

	return false, nil
}

func init() {
	_КлючиВсеНов()
	Ключи._Доб("MODULE", []мКлюч.СКлюч{"MODULE", "МОДУЛЬ"})
	Ключи._Доб("COMMENTDEF", []мКлюч.СКлюч{"COMMENTDEF", "КОММЕНТАРИИ", "КОММЕНТ"})
	Ключи._Доб("END", []мКлюч.СКлюч{"END", "КОНЕЦ"})
	Ключи._Доб("IMPORT", []мКлюч.СКлюч{"IMPORT", "ИМПОРТ"})
	Ключи._Доб("TYPE", []мКлюч.СКлюч{"TYPE", "ТИПЫ"})
	Ключи._Доб("CONST", []мКлюч.СКлюч{"CONST", "КОНСТ"})
	Ключи._Доб("VAR", []мКлюч.СКлюч{"VAR", "ПЕРЕМ"})
	Ключи._Доб("PROCDEF", []мКлюч.СКлюч{"PROCDEF", "ПРОЦОПР"})
	Ключи._Доб("BEGIN", []мКлюч.СКлюч{"BEGIN", "НАЧАЛО", "НАЧ"})
	Ключи._Доб(";", []мКлюч.СКлюч{";"})
	Ключи._Доб(".", []мКлюч.СКлюч{"."})
	Ключи._Доб(",", []мКлюч.СКлюч{","})
	Ключи._Доб(":=", []мКлюч.СКлюч{":="})
}
