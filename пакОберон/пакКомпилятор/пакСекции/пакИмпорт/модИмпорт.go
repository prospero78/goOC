package пакИмпорт

// модИмпорт

/*
	Модуль предоставляет тип для анализа секции импорта
*/

import (
	пакКонс "../../../пакКонсоль"
	пакСлово "../../пакСущность/пакСлово"
	пакСекция "../пакСекция"
	пакФмт "fmt"
)

//ТуИмпорт -- тип выделяети хранит слова импорта
type ТуИмпорт struct {
	_слова      *[]*пакСлово.ТуСлово
	словаМодуля *[]*пакСлово.ТуСлово
}

//Новый -- Создаёт и возвращает новый экземпляр для выделения слов импорта модуля
func Новый() (импорт *ТуИмпорт, ош error) {
	пакКонс.Конс.Отладить("пакСекции.пакИмпорт.Новый()")
	импорт = &ТуИмпорт{}
	return импорт, ош
}

//Обработать -- главная функция обработки секции импорт
func (сам *ТуИмпорт) Обработать(пСловаМодуля []*пакСлово.ТуСлово) (ош error) {
	пакКонс.Конс.Отладить("ТуИмпорт.Обработать()")
	сам._слова = &пСловаМодуля
	сам.словаМодуля = &пСловаМодуля
	if сам._ЕслиИмпорт() {
		if ош := сам._ЕслиИмпортОдин(); ош != nil {
			ош = пакФмт.Errorf("ТуИмпорт.Обработать(): ошибка при проверке одной секции импорт\n\t%v", ош)
			return ош
		}
		if ош := сам._ЕслиИмпортОграничен(); ош != nil {
			ош = пакФмт.Errorf("ТуИмпорт.Обработать(): ошибка при проверке ограничения секции импорта\n\t%v", ош)
			return ош
		} else {
			пакСекция.СловаСекцииПолучить(сам)
			return nil
		}

	} else {
		return nil
	}
	return nil
}

func (сам *ТуИмпорт) _ЕслиИмпортОдин() (ош error) {
	пакКонс.Конс.Отладить("ТуИмпорт._ЕслиИмпортОдин()")
	счётИмпорт := 0
	словоНом := 0
	словаВсего := len(*сам.словаМодуля)
	for словоНом < словаВсего {
		слово := (*сам.словаМодуля)[словоНом]
		словоНом++
		for индекс := range пакСлово.КсИмпорт {
			стрИмпорт, _ := слово.Строка()
			if стрИмпорт == пакСлово.КсИмпорт[индекс] {
				счётИмпорт++
			}
			if счётИмпорт > 1 {
				стрИсх, _ := слово.СтрИсх()
				ош = пакФмт.Errorf("пакСекции.пакИмпорт.ТуИмпорт._ЕслиИмпортОдин(): IMPORT два раза в одном модуле запрещён\n\t%v", стрИсх)
				return ош
			}
		}
	}

	return nil
}
func (сам *ТуИмпорт) _ЕслиИмпорт() (рез bool) {
	слово := (*сам.словаМодуля)[0]
	//Цикл по словарю слова IMPORT
	for _, слИмпорт := range пакСлово.КсИмпорт {
		//Проверка на все возможные значения
		стрИмпорт, _ := слово.Строка()
		if стрИмпорт == слИмпорт {
			рез = true
			пакСекция.СловаСекцииОбрезать(сам)
		}
	}
	return рез
}

func (сам *ТуИмпорт) _ЕслиИмпортОграничен() (ош error) {
	Дальше := func(слово *пакСлово.ТуСлово) bool {
		стр, _ := слово.Строка()
		return стр != ";"
	}
	цСловоНом := 0
	слово := (*сам.словаМодуля)[0]
	for Дальше(слово) && (цСловоНом < len(*сам.словаМодуля)) {
		цСловоНом++
		слово = (*сам.словаМодуля)[цСловоНом]
	}
	if Дальше(слово) {
		ош = пакФмт.Errorf("ТуИмпорт._ЕслиИмпортОграничен(): секция импорта ничем не ограничена")
		return ош
	}
	пакСекция.КонецУст(сам)
	return ош
}

//Слова -- возвращает слова модуля
func (сам *ТуИмпорт) СловаМодуля() (слова *[]*пакСлово.ТуСлово) {
	return сам.словаМодуля
}

// СловаИмпорт -- Возвращает слова импорта
func (сам *ТуИмпорт) СловаСекции() (слова *[]*пакСлово.ТуСлово) {
	return сам._слова
}

// СловаУст -- устанавлиает слова после обрезки секции слов
func (сам *ТуИмпорт) СловаСекцииУст(слова []*пакСлово.ТуСлово) {
	сам._слова = &слова
}

// Секция -- возвращает тип секции
func (сам *ТуИмпорт) Секция() (стрСекция string) {
	return "ИМПОРТ"
}
