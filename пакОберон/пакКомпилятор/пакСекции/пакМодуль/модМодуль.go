// модМодуль
package пакМодуль

/*
Предоставляет возможность сканеру секций определеить правильно ли
описан модуль.
*/

import (
	пакКонс "../../../пакКонсоль"
	пакСлово "../../пакСущность/пакСлово"
	пакСекция "../пакСекция"
	пакФмт "fmt"
)

type ТуМодуль struct {
	_слова *[]*пакСлово.ТуСлово // Сохраняет все слова модуля
	_имя   *пакСлово.ТуСлово    // Сохраняет имя модуля
}

func Новый() (модуль *ТуМодуль, ош error) {
	пакКонс.Конс.Отладить("пакСекции.пакМодуль.Новый()")
	модуль = &ТуМодуль{}
	return модуль, ош
}

func (сам *ТуМодуль) Обработать(пСловаМодуля []*пакСлово.ТуСлово) (ош error) {

	пакКонс.Конс.Отладить("ТуМодуль.Обработать()")
	сам._слова = &пСловаМодуля
	пакФмт.Printf("Всего слов в модуле после отбрасывания комментариев1 > [%v]\n", len(*сам._слова))

	if ош := сам.__МодульНачало_Проверить(); ош != nil {
		ош = пакФмт.Errorf("ТуМодуль.Обработать(): ошибка при поиске начала модуля\n\t%v", ош)
		return ош
	}
	if ош := сам.__Имя_Проверить(); ош != nil {
		ош = пакФмт.Errorf("ТуМодуль.Обработать(): ошибка при поиске имени модуля\n\t%v", ош)
		return ош
	}
	if ош := сам.__Разделитель_Проверить(); ош != nil {
		ош = пакФмт.Errorf("ТуМодуль.Обработать(): ошибка при поиске разделителя заголовка модуля\n\t%v", ош)
		return ош
	}
	if ош := сам.__МодульКонец_Найти(); ош != nil {
		ош = пакФмт.Errorf("ТуМодуль.Обработать(): ошибка при поиске конца модуля\n\t%v", ош)
		return ош
	}
	if ош := сам.__МодульОдин_Проверить(); ош != nil {
		ош = пакФмт.Errorf("ТуМодуль.Обработать(): ошибка при поиске единственного MODULE\n\t%v", ош)
		return ош
	}
	пакФмт.Printf("Всего слов в модуле после отбрасывания комментариев2 > [%v]\n", len(*сам._слова))
	return ош
}

// Проверяет имя модуля в тексте
func (сам *ТуМодуль) __Имя_Проверить() (ош error) {
	пакКонс.Конс.Отладить("ТуМодуль.__Имя_Проверить()")
	слово := (*сам._слова)[0]
	//пакКонс.Конс.Отладить("Проверка имени модуля: \"" + слово.Строка() + "\"")
	if слово.ЕслиИмя_Строго() {
		сам._имя = слово
	} else {
		ош = пакФмт.Errorf("ТуМодуль.__Имя_Проверить(): такое имя модуля запрещено\n\tимя=%v\n\tСтрока=%v", слово.Строка(), слово.СтрИсх())
		return ош
	}
	пакСекция.Слова_Обрезать(сам)

	return ош
}

// Проверяет разделитель после имени модуля в начале
func (сам *ТуМодуль) __Разделитель_Проверить() (ош error) {
	пакКонс.Конс.Отладить("ТуМодуль.__Разделитель_Проверить()")
	слово := (*сам._слова)[0]
	if слово.Строка() != ";" {
		ош = пакФмт.Errorf("ТуМодуль.__Разделитель_Проверить(): ошибка в окончании названия модуля\n\t%v %v",
			слово.Строка(), слово.СтрИсх())
		return ош
	}
	пакСекция.Слова_Обрезать(сам)
	return ош
}

func (сам *ТуМодуль) __МодульКонец_Найти() (ош error) {
	пакКонс.Конс.Отладить("ТуМодуль.__МодульКонец_Найти()")
	цСчётОбр := len(*сам._слова) - 1
	for цСчётОбр >= 0 {
		слово_точка := (*сам._слова)[цСчётОбр]
		// Нашли конечную точку?
		if слово_точка.Строка() == "." {
			// Попытка найти END. КсМодуль содержит множество слов
			слово_конец := (*сам._слова)[цСчётОбр-2]
			for _, строка_конец := range пакСлово.КсКонец {
				if слово_конец.Строка() == строка_конец {
					// Попытка проверить совпадение имя модуля и конца модуля
					слово_имя := (*сам._слова)[цСчётОбр-1]
					if слово_имя.Строка() == сам._имя.Строка() {
						сам.__Хвост_Отбросить(цСчётОбр)
						return
					}
					// Это гарантированная ошибка, так как не было возврата
					ош = пакФмт.Errorf("ТуМодуль.__КонецМодуль_Найти(): имя модуля в начале и в конце модуля не совпадают\n\t%v %v",
						сам._имя.Строка(), слово_имя.Строка())
					return ош
				}
			}
		}
		цСчётОбр--
	}
	if цСчётОбр == 0 { // Гарантированная ошибка. Так быть не может.
		ош = пакФмт.Errorf("ТуМодуль.__КонецМодуль_Найти(): нет завершающей точки в модуле")
		return ош
	}
	return ош
}

// Отбросить всё, что за END <name_module>.
func (сам *ТуМодуль) __Хвост_Отбросить(пСчётОбр int) {
	//пакКонс.Конс.Отладить("Хвост отбросить")
	индекс := 0
	var слова []*пакСлово.ТуСлово
	for индекс < (пСчётОбр - 2) {
		слова = append(слова, (*сам._слова)[индекс])
		индекс++
	}
	сам._слова = &слова
	//пакКонс.Конс.Отладить("Последнее слово перед концом модуля:" + пакФмт.Sprintf("%v", пСчётОбр))
}

// Проверяет, что MODULE реально один в модуле, первый уже отброшен
func (сам *ТуМодуль) __МодульОдин_Проверить() (ош error) {
	пакКонс.Конс.Отладить("ТуМодуль.__МодульОдин_Проверить()")
	for индекс := range *сам._слова {
		слово := (*сам._слова)[индекс]
		for индекс2 := range пакСлово.КсМодуль {
			if слово.Строка() == пакСлово.КсМодуль[индекс2] {
				ош = пакФмт.Errorf("ТуМодуль.__МодульОдин_Проверить(): MODULE встречается больше одного раза")
				return ош
			}
		}
	}
	return ош
}

// Прверяет, что модуль начинается правильно
func (сам *ТуМодуль) __МодульНачало_Проверить() (ош error) {
	пакКонс.Конс.Отладить("ТуМодуль.__МодульНачало_Проверить()")
	бРез := false
	слово := (*сам._слова)[0]
	for индекс := range пакСлово.КсМодуль {
		if слово.Строка() == пакСлово.КсМодуль[индекс] {
			бРез = true
		}
	}
	if !бРез {
		ош = пакФмт.Errorf("ТуМодуль.__МодульНачало_Проверить(): модуль не начинается с MODULE")
	}
	пакСекция.Слова_Обрезать(сам)
	return ош
}

// Устанавлиает слова после обрезки секции слов
func (сам *ТуМодуль) Слова_Уст(слова []*пакСлово.ТуСлово) {
	сам._слова = &слова
}

// Возвращает список слов
func (сам *ТуМодуль) Слова() (слова *[]*пакСлово.ТуСлово) {
	return сам._слова
}
