package пакМодуль

// модМодуль

/*
	Предоставляет возможность сканеру секций определеить правильно ли
	описан модуль.
*/

import (
	пакКонс "../../../пакКонсоль"
	пакСлово "../../пакСущность/пакСлово"
	пакСекция "../пакСекция"
	пакФмт "fmt"
)

//ТуМодуль -- предоставляет тип, содержащий слова модуля
type ТуМодуль struct {
	секция *пакСекция.ТуСекция
	имя    *пакСлово.ТуСлово //Имя модуля из слов модуля
}

//Новый -- возвращает новый экземпляр типа для выделения слов модуля
func Новый() (модуль *ТуМодуль, ош error) {
	пакКонс.Конс.Отладить("пакСекции.пакМодуль.Новый()")
	секция := пакСекция.Новый("МОДУЛЬ")
	модуль = &ТуМодуль{секция: секция}
	return модуль, ош
}

//Обработать -- обеспечивает выделение слов модуля
func (сам *ТуМодуль) Обработать(пСловаМодуля []*пакСлово.ТуСлово) (ош error) {

	пакКонс.Конс.Отладить("ТуМодуль.Обработать()")
	сам.секция.СловаУст(пСловаМодуля)
	пакФмт.Printf("Всего слов в модуле после отбрасывания комментариев1 > [%v]\n", len(сам.секция.Слова()))

	if ош := сам._МодульНачалоПроверить(); ош != nil {
		ош = пакФмт.Errorf("ТуМодуль.Обработать(): ошибка при поиске начала модуля\n\t%v", ош)
		return ош
	}
	if ош := сам._ИмяПроверить(); ош != nil {
		ош = пакФмт.Errorf("ТуМодуль.Обработать(): ошибка при поиске имени модуля\n\t%v", ош)
		return ош
	}
	if ош := сам._РазделительПроверить(); ош != nil {
		ош = пакФмт.Errorf("ТуМодуль.Обработать(): ошибка при поиске разделителя заголовка модуля\n\t%v", ош)
		return ош
	}
	if ош := сам._МодульКонецНайти(); ош != nil {
		ош = пакФмт.Errorf("ТуМодуль.Обработать(): ошибка при поиске конца модуля\n\t%v", ош)
		return ош
	}
	if ош := сам._МодульОдинПроверить(); ош != nil {
		ош = пакФмт.Errorf("ТуМодуль.Обработать(): ошибка при поиске единственного MODULE\n\t%v", ош)
		return ош
	}
	пакФмт.Printf("Всего слов в модуле после обработки > [%v]\n", len(сам.секция.Слова()))
	return ош
}

// Проверяет имя модуля в тексте
func (сам *ТуМодуль) _ИмяПроверить() (ош error) {
	пакКонс.Конс.Отладить("ТуМодуль._ИмяПроверить()")
	слово := сам.секция.Слова()[0]
	//пакКонс.Конс.Отладить("Проверка имени модуля: \"" + слово.Строка() + "\"")
	if слово.ЕслиИмяСтрого() {
		сам.имя = слово
	} else {
		стрСтрока, _ := слово.Строка()
		стрИсх, _ := слово.СтрИсх()
		ош = пакФмт.Errorf("ТуМодуль._ИмяПроверить(): такое имя модуля запрещено\n\tимя=%v\n\tСтрока=%v", стрСтрока, стрИсх)
		return ош
	}
	сам.секция.СловаОбрезать()

	return ош
}

// Проверяет разделитель после имени модуля в начале
func (сам *ТуМодуль) _РазделительПроверить() (ош error) {
	пакКонс.Конс.Отладить("ТуМодуль._РазделительПроверить()")
	слово := сам.секция.Слова()[0]
	if стрСтрока, ош := слово.Строка(); ош == nil {
		if стрСтрока != ";" {
			стрИсх, _ := слово.СтрИсх()
			ош = пакФмт.Errorf("ТуМодуль._РазделительПроверить(): ошибка в окончании названия модуля\n\t%v %v",
				стрСтрока, стрИсх)
			return ош
		}
	} else {
		стрИсх, _ := слово.СтрИсх()
		ош = пакФмт.Errorf("ТуМодуль._РазделительПроверить(): ошибка при проверке разделителя\n\t%v %v",
			стрСтрока, стрИсх)
		return ош
	}
	сам.секция.СловаОбрезать()
	return nil
}

func (сам *ТуМодуль) _МодульКонецНайти() (ош error) {
	пакКонс.Конс.Отладить("ТуМодуль._МодульКонецНайти()")
	цСчётОбр := len(сам.секция.Слова()) - 1
	for цСчётОбр >= 0 {
		словоТочка := сам.секция.Слова()[цСчётОбр]
		// Нашли конечную точку?
		стрТочка, _ := словоТочка.Строка()
		if стрТочка == "." {
			// Попытка найти END. КсМодуль содержит множество слов
			словоКонец := сам.секция.Слова()[цСчётОбр-2]
			for _, строкаКонец := range пакСлово.КсКонец {
				стрКонец, _ := словоКонец.Строка()
				if стрКонец == строкаКонец {
					// Попытка проверить совпадение имя модуля и конца модуля
					словоИмя := сам.секция.Слова()[цСчётОбр-1]
					стрИмя, _ := сам.имя.Строка()
					стрИмя2, _ := словоИмя.Строка()
					if стрИмя2 == стрИмя {
						сам._ХвостОтбросить(цСчётОбр)
						return
					}
					// Это гарантированная ошибка, так как не было возврата
					ош = пакФмт.Errorf("ТуМодуль._КонецМодульНайти(): имя модуля в начале и в конце модуля не совпадают\n\t%v %v",
						стрИмя, стрИмя2)
					return ош
				}
			}
		}
		цСчётОбр--
	}
	if цСчётОбр == 0 { // Гарантированная ошибка. Так быть не может.
		ош = пакФмт.Errorf("ТуМодуль.__КонецМодуль_Найти(): нет завершающей точки в модуле")
		return ош
	}
	return ош
}

// Отбросить всё, что за END <name_module>.
func (сам *ТуМодуль) _ХвостОтбросить(пСчётОбр int) {
	//пакКонс.Конс.Отладить("Хвост отбросить")
	индекс := 0
	var слова []*пакСлово.ТуСлово
	for индекс < (пСчётОбр - 2) {
		слова = append(слова, сам.секция.Слова()[индекс])
		индекс++
	}
	сам.секция.СловаУст(слова)
	//пакКонс.Конс.Отладить("Последнее слово перед концом модуля:" + пакФмт.Sprintf("%v", пСчётОбр))
}

// Проверяет, что MODULE реально один в модуле, первый уже отброшен
func (сам *ТуМодуль) _МодульОдинПроверить() (ош error) {
	пакКонс.Конс.Отладить("ТуМодуль._МодульОдинПроверить()")
	for индекс := range сам.секция.Слова() {
		слово := сам.секция.Слова()[индекс]
		for индекс2 := range пакСлово.КсМодуль {
			стрМодуль, _ := слово.Строка()
			if стрМодуль == пакСлово.КсМодуль[индекс2] {
				ош = пакФмт.Errorf("ТуМодуль._МодульОдинПроверить(): MODULE встречается больше одного раза")
				return ош
			}
		}
	}
	return ош
}

// Проверяет, что модуль начинается правильно
func (сам *ТуМодуль) _МодульНачалоПроверить() (ош error) {
	пакКонс.Конс.Отладить("ТуМодуль.__МодульНачало_Проверить()")
	бРез := false
	слово := сам.секция.Слова()[0]
	for индекс := range пакСлово.КсМодуль {
		стрМодуль, _ := слово.Строка()
		if стрМодуль == пакСлово.КсМодуль[индекс] {
			бРез = true
		}
	}
	if !бРез {
		ош = пакФмт.Errorf("ТуМодуль._МодульНачалоПроверить(): модуль не начинается с MODULE")
	}
	сам.секция.СловаОбрезать()
	return ош
}

// СловаСекцииУст -- устанавливает слова после обрезки секции модуля (это и есть глобальная секция)
func (сам *ТуМодуль) СловаСекцииУст(слова []*пакСлово.ТуСлово) {
	сам.секция.СловаУст(слова)
}

// СловаМодуля -- возвращает список слов модуля
func (сам *ТуМодуль) СловаМодуля() (слова []*пакСлово.ТуСлово) {
	return сам.секция.Слова()
}
