package пакКомпилятор

// модКомпилятор

/*
	Предоставляет тип компилятора для всего Оберона
*/

import (
	пакКонс "../пакКонсоль"
	пакСекции "./пакСекции"
	пакСканер "./пакСканер"
	пакФмт "fmt"
)

//ТКомпилятор -- предоставляет тип компилятора
type ТКомпилятор struct {
	сканер   *пакСканер.ТСканер
	конс     *пакКонс.ТКонсоль
	ИмяФайла string
	секции   *пакСекции.ТСекции
}

//Новый -- возвращает новый экземпляр типа компилятора
func Новый() (компилятор *ТКомпилятор, ош error) {
	пакКонс.Конс.Отладить("пакКомплиятор.Новый()")
	компилятор = new(ТКомпилятор)
	if компилятор.сканер, ош = пакСканер.Новый(); ош != nil {
		ош = пакФмт.Errorf("ПакКомпилятор.Новый(): ошибка присоздании ТуСканер\n\t%v", ош)
		return nil, ош
	}
	if компилятор.секции, ош = пакСекции.Новый(); ош != nil {
		ош = пакФмт.Errorf("ПакКомпилятор.Новый(): ошибка присоздании ТуСканер\n\t%v", ош)
		return nil, ош
	}
	компилятор.конс = пакКонс.Конс
	return компилятор, ош
}

// Обработать -- начинает обработку предоставляемого модуля
func (сам *ТКомпилятор) Обработать(пИмяФайла string) (ош error) {
	сам.конс.Отладить("ТуКомпилятор.Обработать()")
	сам.ИмяФайла = пИмяФайла
	if _ош := сам.сканер.Обработать(пИмяФайла); _ош != nil {
		ош = пакФмт.Errorf("ТКомпилятор.Обработать(): ошибка при работе сканера\n\t%v", _ош)
		return ош
	}
	if _ош := сам.секции.Обработать(сам.сканер.Исх.СловаМодуля); _ош != nil {
		ош = пакФмт.Errorf("ТКомпилятор.Обработать(): ошибка при работе разбиения секций\n\t%v", _ош)
		return ош
	}
	return nil
}
