// модИсходникФайл
package пакИсходникФайл

/*
Пакет предоставляет тип для чтения файла и записи его же.
*/

import (
	пакКонс "../../../../пакКонсоль"
	пакОш "../../../пакСущность/пакОшибка"

	пакФмт "fmt"
	пакОс "os"
	//пакУтф "unicode/utf8"
)

type ТуИсхФайл struct {
	конс   *пакКонс.ТуКонсоль
	размер int
	текст  string
	ош     *пакОш.ТуОшибка
}

func Новый() (файл *ТуИсхФайл) {
	пакКонс.Конс.Отладить("пакИсхФайл.Новый()")
	файл = &ТуИсхФайл{
		конс: пакКонс.Конс,
		ош:   пакОш.Новый("ТуИсхФайл"),
	}
	return файл
}

func (сам *ТуИсхФайл) Считать(пИмяФайла string) {
	сам.конс.Отладить("ТуИсхФайл.Считать()")
	if пИмяФайла == "" {
		пИмяФайла = "Hello.o7"
	}
	файл, _ := пакОс.Open(пИмяФайла)
	defer файл.Close()
	// Размер файла в байтах
	размер, _ := файл.Stat()

	// Массив байт под размер текста
	текст := make([]byte, размер.Size())

	// Считали текст в байтовый срез
	_, _ = файл.Read(текст)

	// Строка по размеру байтов
	сам.текст = string(текст)

	сам.размер = len([]rune(сам.текст))
}

// Возвращает литеру по номеру руны
func (сам *ТуИсхФайл) Лит(пПоз int) (лит string) {
	if пПоз < 0 {
		сам.ош.Внутр("Лит", "Указатель литеры пПоз не может быть < 0")
		return ""
	} else {
		if пПоз >= сам.размер {
			сам.ош.Внутр("Лит", "Указатель литеры пПоз больше последней литеры, пПоз="+пакФмт.Sprintf("%v", пПоз))
			return ""
		} else {
			текст := []rune(сам.текст)
			лит = string(текст[пПоз])
			return лит
		}
	}

}

// Возвращает полностью исходный текст в отдельном срезе рун
func (сам *ТуИсхФайл) Исходник() (текст string) {
	//сам.конс.Отладить("ццц " + string(сам.текст) + " длина: " + пакФмт.Sprint("", len(сам.текст)))
	текст = сам.текст
	//copy(текст, сам.текст)
	return текст
}

func (сам *ТуИсхФайл) Исх_Печать() {
	сам.конс.Печать(string(сам.текст))
}
