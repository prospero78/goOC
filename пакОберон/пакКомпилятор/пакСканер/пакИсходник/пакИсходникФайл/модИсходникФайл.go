// модИсходникФайл
package пакИсходникФайл

/*
Пакет предоставляет тип для чтения файла и записи его же.
*/

import (
	пакКонс "../../../../пакКонсоль"
	//пакФмт "fmt"
	пакОс "os"
	//пакУтф "unicode/utf8"
)

type ТуИсхФайл struct {
	конс   *пакКонс.ТуКонсоль
	размер int
	текст  string
}

func Новый() (файл *ТуИсхФайл) {
	пакКонс.Конс.Отладить("пакИсхФайл.Новый()")
	файл = new(ТуИсхФайл)
	файл.конс = пакКонс.Конс
	return файл
}

func (сам *ТуИсхФайл) Считать(пИмяФайла string) {
	сам.конс.Отладить("ТуИсхФайл.Считать()")
	if пИмяФайла == "" {
		пИмяФайла = "Hello.o7"
	}
	файл, _ := пакОс.Open(пИмяФайла)
	defer файл.Close()
	// Размер файла в байтах
	размер, _ := файл.Stat()

	// Массив байт под размер текста
	текст := make([]byte, размер.Size())

	// Считали текст
	_, _ = файл.Read(текст)

	//Сколько занимает в рунах
	//сам.размер = пакУтф.RuneCount(текст)

	// Массив по размеру рун
	//сам.текст = make([]rune, сам.размер)
	сам.текст = string(текст)

	// Теперь перевариавем байты в руны
	//индекс := 0
	//for len(текст) > 0 {
	//	руна, цРазмер := пакУтф.DecodeRune(текст)
	//	сам.текст[индекс] = руна
	//	текст = текст[цРазмер:]
	//	индекс += 1
	//}
	//сам.конс.Отладить("####################################################")
	//сам.конс.Отладить(string(сам.текст))
	//сам.конс.Отладить("####################################################")
}

// Возвращает литеру по номеру руны
func (сам *ТуИсхФайл) Лит(пПоз int) (лит string) {
	if пПоз < 0 {
		сам.конс.Ошибка("Указатель литеры пПоз не может быть < 0")
	}
	if пПоз > сам.размер {
		сам.конс.Ошибка("Указатель литеры пПоз юольше последней литеры")
	}
	текст := []rune(сам.текст)
	лит = string(текст[пПоз])
	return лит
}

// Возвращает полностью исходный текст в отдельном срезе рун
func (сам *ТуИсхФайл) Исходник() (текст string) {
	//сам.конс.Отладить("ццц " + string(сам.текст) + " длина: " + пакФмт.Sprint("", len(сам.текст)))
	текст = сам.текст
	//copy(текст, сам.текст)
	return текст
}

func (сам *ТуИсхФайл) Исх_Печать() {
	сам.конс.Печать(string(сам.текст))
}
