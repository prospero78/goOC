// модИсходникСтроки
package пакИсходникСтроки

/*
Пакет предоставляет тип, который хранит построчно исходник.
К строке можно обратиться по номеру, или полностью получить массив строк
*/
import (
	пакКонс "../../../../пакКонсоль"
	пакФмт "fmt"
)

type TStrune []rune

type ТуИсхСтр struct {
	конс   *пакКонс.ТуКонсоль
	ИсхСтр []TStrune
}

func Новый() (исхСтр *ТуИсхСтр) {
	исхСтр = new(ТуИсхСтр)
	return исхСтр
}

func (сам *ТуИсхСтр) НаСтроки_Разбить(пИсх []rune) {
	лит := ""
	счёт := 1
	for _, эл := range пИсх {
		лит = string(эл)
		if лит == "\n" {
			счёт++
		}
	}
	счёт_всего := счёт
	сам.ИсхСтр = make([]TStrune, счёт_всего+1) //нулевая строка не используется
	сам.конс.Отладить(пакФмт.Sprintf("В исходнике %v строк", счёт_всего))

	// Теперь построчное разделение
	// Подсчитаем на какой руне заканчивается текущая строка
	счёт = 1
	поз := 0 //текущая позиция литеры
	поз_стар := 0
	for поз < счёт_всего {
		if лит == "\n" {
			струна := строка_Новая(поз - 1 - поз_стар)
			for итер := поз_стар; итер < поз; итер++ {
				струна[итер] = пИсх[итер]
				сам.конс.Отладить(string(пИсх[итер]))
			}
			сам.конс.Отладить(пакФмт.Sprintf("%v: %v", счёт, string(струна)))
			сам.ИсхСтр[счёт] = струна
			счёт++
			поз_стар = поз + 1
		}
		поз++
	}
}

func строка_Новая(длина int) TStrune {
	var стр TStrune //нулевая руна не используется
	return стр
}
