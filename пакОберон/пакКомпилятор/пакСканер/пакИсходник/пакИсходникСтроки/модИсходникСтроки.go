// модИсходникСтроки
package пакИсходникСтроки

/*
Пакет предоставляет тип, который хранит построчно исходник.
К строке можно обратиться по номеру, или полностью получить массив строк
*/
import (
	пакКонс "../../../../пакКонсоль"
	пакФмт "fmt"
)

type ТуИсхСтр struct {
	конс   *пакКонс.ТуКонсоль
	ИсхСтр [][]rune
}

func Новый() (исхСтр *ТуИсхСтр) {
	исхСтр = new(ТуИсхСтр)
	return исхСтр
}

func (сам *ТуИсхСтр) НаСтроки_Разбить(пИсх []rune) {
	лит := ""
	счёт := 1
	for _, эл := range пИсх {
		лит = string(эл)
		if лит == "\n" {
			счёт++
		}
	}
	счёт_всего := счёт
	сам.ИсхСтр = make([][]rune, счёт_всего+1) //нулевая строка не используется
	сам.конс.Отладить(пакФмт.Sprintf("В исходнике %v строк", счёт_всего))

	// Теперь построчное разделение
	// Подсчитаем на какой руне заканчивается текущая строка
	счёт = 1
	поз := 0 //текущая позиция литеры
	поз_стар := 0
	for поз < счёт_всего {
		if лит == "\n" {
			сам.ИсхСтр[счёт] = строка_Новая(поз - 1 - поз_стар)
			for итер := поз_стар; итер < поз; итер++ {
				сам.ИсхСтр[счёт][итер] = пИсх[итер]
			}
			сам.конс.Отладить(пакФмт.Sprintf("%v: %v", счёт, string(сам.ИсхСтр[счёт])))
			счёт++
			поз_стар = поз + 1
		}
		поз++
	}
}

func строка_Новая(длина int) (стр []rune) {
	стр = make([]rune, длина+1) //нулевая руна не используется
	return стр
}
