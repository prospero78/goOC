// модИсходникСтроки
package пакИсходникСтроки

/*
Пакет предоставляет тип, который хранит построчно исходник.
К строке можно обратиться по номеру, или полностью получить массив строк
*/
import (
	пакКонс "../../../../пакКонсоль"
	пакФмт "fmt"
	пакСтр "strings"
)

type TStrune []rune

type ТуИсхСтр struct {
	конс   *пакКонс.ТуКонсоль
	ИсхСтр []string
}

func Новый() (исхСтр *ТуИсхСтр) {
	исхСтр = new(ТуИсхСтр)
	return исхСтр
}

func (сам *ТуИсхСтр) НаСтроки_Разбить(пИсх []rune) {

	стрИсх := string(пИсх)
	сам.ИсхСтр = пакСтр.Split(стрИсх, "\n")
	/*
		for _, эл := range пИсх {
			лит = string(эл)
			if лит == "\n" {
				break
				}
				else{
				лит_текущ++
			}
		}
		счёт_всего := счёт
		сам.ИсхСтр = make([]TStrune, счёт_всего+1) //нулевая строка не используется
		сам.конс.Отладить(пакФмт.Sprintf("В исходнике %v строк", счёт_всего))

		// Теперь построчное разделение
		// Подсчитаем на какой руне заканчивается текущая строка
		счёт = 1
		поз := 0 //текущая позиция литеры
		поз_стар := 0
		for поз < счёт_всего {
			if лит == "\n" {
				струна := строка_Новая(поз - 1 - поз_стар)
				for итер := поз_стар; итер < поз; итер++ {
					струна[итер] = пИсх[итер]
					сам.конс.Отладить(string(пИсх[итер]))
				}
				сам.конс.Отладить(пакФмт.Sprintf("%v: %v", счёт, string(струна)))
				сам.ИсхСтр[счёт] = струна
				счёт++
				поз_стар = поз + 1
			}
			поз++
		}*/
	for итер, стр := range сам.ИсхСтр {
		if len(стр) > 1 {
			стр = стр[:len(стр)-1]
			сам.ИсхСтр[итер] = стр
		}
		сам.конс.Печать(пакФмт.Sprintf("%v: %v", итер, сам.ИсхСтр[итер]))
	}
}

func строка_Новая(длина int) TStrune {
	var стр TStrune //нулевая руна не используется
	return стр
}
