// модСлово
package пакСлово

/*
Предоставляет тип слова для построения AST.
Слово -- кусочек текста в исходнике.
Обладает несколькими свойствами:
1. Группа литер (само слово, может быть из одной литеры)
2. Координаты.
3. Строка, в которой он находится.
*/

import (
	пакКонс "../../../пакКонсоль"
	пакКоорд "../../пакСущность/пакКоорд"
	пакОш "../пакОшибка"
	пакТипы "../пакТипы"
	пакФмт "fmt"
	"strings"
)

var (
	запрет_имя = []string{КсМодуль, КсИмпорт, КсКонст, КсТипы, КсБулево, КсБайт, КсЦелое, КсЛит, КсНабор,
		КсВещ, КсПер, КсУказ, КсДо, КсМассив, КсИз, КсНачало, КсКонец, КсПроцедура, КсДля,
		КсПока, КсПовтор, КсЗапись, КсЯвляется}
)

var слов_всего = 0

type ТуСлово struct {
	стрИсх   пакТипы.ТСтрИсх       // Строка исходника
	стрСлово пакТипы.ТСтрСлово     // Строка слова
	цРод     пакТипы.ТРод          // род слова
	Ош       *пакОш.ТуОшибка       // Возникшая ошибка в слове
	конс     *пакКонс.ТуКонсоль    // Системная консоль
	Коорд    *пакКоорд.ТуКоордФикс // Координаты слова в исходном тексте
}

func Новое(пНомСтр, пНомПоз int, пСтрока string) (слово *ТуСлово, ош error) {
	//Проверяет входящую строку на минимальную длину.
	слово_проверить := func(пСтрока string) { // Вспомогательная функция
		if len(пСтрока) == 0 {
			стрСбщ := пСтрока + " Строка имеет длину 0"
			panic(стрСбщ)
		}
	}

	род_проверить := func(сам *ТуСлово, пСтрока string) { //Устанавливает род слова.
		var род int
		switch {
		case string(пСтрока) == ";":
			род = КТочкаЗапятая
		case string(пСтрока) == ",":
			род = КЗапятая
		case string(пСтрока) == "+":
			род = КПлюс
		case string(пСтрока) == "-":
			род = КМинус
		case string(пСтрока) == "/":
			род = КДеление
		case string(пСтрока) == "(":
			род = КСкобкаОткрКругл
		case string(пСтрока) == "(*":
			род = ККомментНачать
		case string(пСтрока) == ")":
			род = КСкобкаЗакрКругл
		case string(пСтрока) == "*)":
			род = ККомментЗакончить
		case string(пСтрока) == "*":
			род = КУмножить
		case string(пСтрока) == ":=":
			род = КПрисвоить
		case string(пСтрока) == ":":
			род = КОпределить
		case strings.HasPrefix(пСтрока, "_") || ЕслиПерваяБуква(пСтрока):
			род = КИмя
		case !НеЦифра(пСтрока) || (string(пСтрока[0]) == "."):
			род = КЧисло
		case string(пСтрока) == "=":
			род = КРавно
		case string(пСтрока) == ".":
			род = КТочка
		case пСтрока[0] == '"' && пСтрока[len(пСтрока)-1] == '"':
			род = КСтрока
		default:
			panic("Не могу классифицировать строку, строка=" + string(пСтрока))
		}
		сам.цРод = пакТипы.ТРод(род)
	}

	слово_проверить(пСтрока)
	слово = &ТуСлово{
		стрСлово: пакТипы.ТСтрСлово(пСтрока),
		Ош:       пакОш.Новый("тСлово"),
		конс:     пакКонс.Конс,
	}
	слово.Коорд, ош = пакКоорд.НовыйФикс(пакКоорд.ТЦелСтр(пНомСтр), пакКоорд.ТЦелПоз(пНомПоз))
	if ош != nil {
		ош = пакФмт.Errorf("ПакСлово.Новое(): ошибка при создании ТуКоорд\n %v", ош)
	}
	род_проверить(слово, пСтрока)
	return слово, ош
}

// Проверяет наличие первой буквы в строке
func ЕслиПерваяБуква(пСтрока string) (бРез bool) {
	бРез = true
	стрНач := string(пСтрока[0])
	if !(strings.Contains(стрНач, стрБуквыВсе)) {
		бРез = false
	}
	return бРез
}

// Проверяет наличие буквы в литере
func ЕслиБуква(пЛит string) (бРез bool) {
	if strings.Contains(пЛит, стрБуквыВсе) {
		бРез = true
	}
	return бРез
}

func ЕслиЦифра(пЛит string) (бРез bool) {
	стрЦифры := "0123456789."
	if strings.Contains(пЛит, стрЦифры) {
		бРез = true
	}
	return бРез
}

func НеЦифра(пСтрока string) (бРез bool) {
	стрЦифры := "0123456789."
	for лит := range пСтрока {
		if !(strings.Contains(string(лит), стрЦифры)) {
			бРез = true
		}
	}
	return бРез
}
