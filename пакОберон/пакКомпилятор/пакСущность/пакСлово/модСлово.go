// модСлово
package пакСлово

/*
Предоставляет тип слова для построения AST.
Слово -- кусочек текста в исходнике.
Обладает несколькими свойствами:
1. Группа литер (само слово, может быть из одной литеры)
2. Координаты.
3. Строка, в которой он находится.
*/

import (
	пакТипы "../пакТипы"
	"strings"
)

const (
	// константы сущностей
	кПусто = iota
	кМодульИмя
	кМодульАлиас
	кЗапятая
	кТочкаЗапятая
	кИмя
	кКомментНачать
	кКомментЗакончить
	кОпределить
	кПрисвоить
	кСкобкаОткрКругл
	кСкобкаЗакрКругл
	кДеление
	кУмножить
	кМинус
	кПлюс
	кЧисло
	кСтрока
	кРавно
	кТочка

	// ключевые слова
	ксМодуль    = "MODULE"
	ксИмпорт    = "IMPORT"
	ксКонст     = "CONST"
	ксТипы      = "TYPE"
	ксБулево    = "BOOLEAN"
	ксБайт      = "BYTE"
	ксЦелое     = "INTEGER"
	ксЛит       = "CHAR"
	ксНабор     = "SET"
	ксВещ       = "REAL"
	ксПер       = "VAR"
	ксУказ      = "POINTER"
	ксДо        = "TO"
	ксМассив    = "ARRAY"
	ксИз        = "OF"
	ксНачало    = "BEGIN"
	ксКонец     = "END"
	ксПроцедура = "PROCEDURE"
	ксДля       = "FOR"
	ксПока      = "WHILE"
	ксПовтор    = "DO"
	ксЗапись    = "RECORD"
	ксЯвляется  = "IS"

	//наборы букв для перебора
	стрБуквыРус = "абвгдеёжзийклмнопрстуфхцчшщьыъэюяАБВШДЕЙЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯ"
	стрБуквыАнг = "abcdefghjiklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	стрБуквыВсе = стрБуквыРус + стрБуквыАнг
)

var (
	запрет_имя = []string{ксМодуль, ксИмпорт, ксКонст, ксТипы, ксБулево, ксБайт, ксЦелое, ксЛит, ксНабор,
		ксВещ, ксПер, ксУказ, ксДо, ксМассив, ксИз, ксНачало, ксКонец, ксПроцедура, ксДля,
		ксПока, ксПовтор, ксЗапись, ксЯвляется}
)

var слов_всего = 0

type ТуСлово struct {
	стрИсх   пакТипы.ТСтрИсх
	стрСлово пакТипы.ТСтрСлово
	цРод     пакТипы.ТРод // род слова
}

func если_цифра(пСтрока []rune) (бРез bool) {
	бРез = true
	стрЦифры := "0123456789."
	for лит := range пСтрока {
		if !(strings.Contains(string(лит), стрЦифры)) {
			бРез = true
		}
	}
	return бРез
}

func Новый(пИсхСтр, пСтрока []rune) (слово *ТуСлово) {
	слово_проверить := func(пИсхСтр []rune, пСтрока []rune) { // Вспомогательная функция
		if len(пСтрока) == 0 {
			стрСбщ := string(пИсхСтр) + " " + string(пСтрока) + " Строка имеет длину 0"
			panic(стрСбщ)
		}
	}
	род_проверить := func(сам *ТуСлово, пСтрока []rune) { //Устанавливает род слова.
		var род int
		switch {
		case string(пСтрока) == ";":
			род = кТочкаЗапятая
		case string(пСтрока) == ",":
			род = кЗапятая
		case string(пСтрока) == "+":
			род = кПлюс
		case string(пСтрока) == "-":
			род = кМинус
		case string(пСтрока) == "/":
			род = кДеление
		case string(пСтрока) == "(":
			род = кСкобкаОткрКругл
		case string(пСтрока) == "(*":
			род = кКомментНачать
		case string(пСтрока) == ")":
			род = кСкобкаЗакрКругл
		case string(пСтрока) == "*)":
			род = кКомментЗакончить
		case string(пСтрока) == "*":
			род = кУмножить
		case string(пСтрока) == ":=":
			род = кПрисвоить
		case string(пСтрока) == ":":
			род = кОпределить
		case strings.HasPrefix(string(пСтрока), "_") || еслиПерваяБуква(пСтрока):
			род = кИмя
		case если_цифра(пСтрока) || (string(пСтрока[0]) == "."):
			род = кЧисло
		case string(пСтрока) == "=":
			род = кРавно
		case string(пСтрока) == ".":
			род = кТочка
		case пСтрока[0] == '"' && пСтрока[len(пСтрока)-1] == '"':
			род = кСтрока
		default:
			panic("Не могу классифицировать строку, строка=" + string(пСтрока))
		}
		сам.цРод = пакТипы.ТРод(род)
	}

	слово_проверить(пИсхСтр, пСтрока)
	слово = new(ТуСлово)
	слово.стрИсх = пакТипы.ТСтрИсх(пИсхСтр)
	слово.стрСлово = пакТипы.ТСтрСлово(пСтрока)
	род_проверить(слово, пСтрока)
	return слово
}

// Проверяет наличие первой буквы в строке
func еслиПерваяБуква(пСтрока []rune) (бРез bool) {
	бРез = true
	стрНач := string(пСтрока[0])
	if !(strings.Contains(стрНач, стрБуквыВсе)) {
		бРез = false
	}
	return бРез
}
