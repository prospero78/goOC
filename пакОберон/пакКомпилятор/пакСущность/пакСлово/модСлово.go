// модСлово
package пакСлово

/*
Предоставляет тип слова для построения AST.
Слово -- кусочек текста в исходнике.
Обладает несколькими свойствами:
1. Группа литер (само слово, может быть из одной литеры)
2. Координаты.
3. Строка, в которой он находится.
*/

import (
	пакТипы "../пакТипы"
	"strings"
)

const (
	// константы сущностей
	кПусто = iota
	кМодульИмя
	кМодульАлиас
	кЗапятая
	кТочкаЗапятая
	кИмя
	кКомментНачать
	кКомментЗакончить
	кОпределить
	кПрисвоить
	кСкобкаОткрКругл
	кСкобкаЗакрКругл
	кДеление
	кУмножить
	кМинус
	кПлюс
	кЧисло
	кСтрока
	кРавно
	кТочка

	// ключевые слова
	ксМодуль    = "MODULE"
	ксИмпорт    = "IMPORT"
	ксКонст     = "CONST"
	ксТипы      = "TYPE"
	ксБулево    = "BOOLEAN"
	ксБайт      = "BYTE"
	ксЦелое     = "INTEGER"
	ксЛит       = "CHAR"
	ксНабор     = "SET"
	ксВещ       = "REAL"
	ксПер       = "VAR"
	ксУказ      = "POINTER"
	ксДо        = "TO"
	ксМассив    = "ARRAY"
	ксИз        = "OF"
	ксНачало    = "BEGIN"
	ксКонец     = "END"
	ксПроцедура = "PROCEDURE"
	ксДля       = "FOR"
	ксПока      = "WHILE"
	ксПовтор    = "DO"
	ксЗапись    = "RECORD"
	ксЯвляется  = "IS"
)

var (
	запрет_имя = []string{ксМодуль, ксИмпорт, ксКонст, ксТипы, ксБулево, ксБайт, ксЦелое, ксЛит, ксНабор,
		ксВещ, ксПер, ксУказ, ксДо, ксМассив, ксИз, ксНачало, ксКонец, ксПроцедура, ксДля,
		ксПока, ксПовтор, ксЗапись, ксЯвляется}
)

var слов_всего = 0

type ТуСлово struct {
	стрИсх   пакТипы.ТСтрИсх
	стрСлово пакТипы.ТСтрСлово
	цРод     пакТипы.ТРод // род слова
}

func если_цифра(пСтрока char)(рез bool){
	for лит == range(пСтрока){
		if strings.Contains("0123456789.")
	}
}

func Новый(пИсхСтр, пСтрока string) (слово *ТуСлово) {
	слово_проверить := func(пИсхСтр, пСтрока string) { // Вспомогательная функция
		if len(пСтрока) == 0 {
			стрСбщ := пИсхСтр + " " + пСтрока + " Строка имеет длину 0"
			panic(стрСбщ)
		}
	}
	род_проверить := func(сам *ТуСлово, пСтрока string) { //Устанавливает род слова.
		var род int
		switch {
		case пСтрока == ";":
			род = кТочкаЗапятая
		case пСтрока == ",":
			род = кЗапятая
		case пСтрока == "+":
			род = кПлюс
		case пСтрока == "-":
			род = кМинус
		case пСтрока == "/":
			род = кДеление
		case пСтрока == "(":
			род = кСкобкаОткрКругл
		case пСтрока == "(*":
			род = кКомментНачать
		case пСтрока == ")":
			род = кСкобкаЗакрКругл
		case пСтрока == "*)":
			род = кКомментЗакончить
		case пСтрока == "*":
			род = кУмножить
		case пСтрока == ":=":
			род = кПрисвоить
		case пСтрока == ":":
			род = кОпределить
		case strings.HasPrefix(пСтрока, "_") || пСтрока[0].isalpha():
			род = кИмя
		case пСтрока[0].isdigit() || пСтрока[0] == ".":
			род = кЧисло
		case пСтрока == "=":
			род = кРавно
		case пСтрока == ".":
			род = кТочка
		case пСтрока[0] == '"' && пСтрока[len(пСтрока)-1] == '"':
			род = кСтрока
		default:
			panic("Не могу классифицировать строку, строка=" + пСтрока)
		}
		сам.цРод = пакТипы.ТРод(род)
	}
	слово_проверить(пИсхСтр, пСтрока)
	слово = new(ТуСлово)
	слово.стрИсх = пакТипы.ТСтрИсх(пИсхСтр)
	слово.стрСлово = пакТипы.ТСтрСлово(пСтрока)
	return слово
}
