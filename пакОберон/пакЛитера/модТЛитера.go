package пакЛитера

/*
	Модуль предоставляет потокобезопасный тип для работы с отдельной литерой.
*/

import (
	мФмт "fmt"
	мСтр "strings"
	мСинх "sync"
)

//СЛит -- специальный строковый тип для хранения литеры исходного текста
type СЛит string

//СЛитКласс -- специальный целочисленный класс для хранения признака класса литеры
type СЛитКласс int

//ИЛит -- интерфейс тип для литеры
type ИЛит interface {
	ЕслиБуква() bool
	ЕслиЦифра() bool
	ЕслиСпецЛит() bool
	Уст(СЛит) error
	Лит() СЛит
	String() string
}

//тЛит -- тип для работы с отдельной литерой
type тЛит struct {
	лит    СЛит
	цКласс СЛитКласс //Хранит класс литеры
	блок   мСинх.Mutex
}

const (
	//наборы букв для перебора
	стрБуквыРус = "абвгдеёжзийклмнопрстуфхцчшщьыъэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯ"
	стрБуквыАнг = "abcdefghjiklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	стрБуквыВсе = стрБуквыРус + стрБуквыАнг

	//CтрЦифры -- список цифр, что могут встречаться в числах
	стрЦифры = "0123456789."

	//Различные специальные литеры, не имеющие смысла в коде
	стрСпецЛит           = "`~!@#№$%^&?\\_"
	кБуква     СЛитКласс = iota + 1
	кСпецЛит
	кЦифра
)

//ЛитераНов -- возвращает ссылку на новый тЛит
func ЛитераНов() (лит ИЛит, ош error) {
	_лит := &тЛит{}
	if _лит == nil {
		return nil, мФмт.Errorf("ЛитераНов(): нет памяти для литеры?\n")
	}
	return _лит, nil
}

// ЕслиБуква -- проверяет наличие буквы в литере
func (сам *тЛит) ЕслиБуква() bool {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	if сам.цКласс == кБуква {
		return true
	}
	return false
}

// ЕслиСпецЛит -- проверяет наличие специальных литер не имеющих смысла в коде
func (сам *тЛит) ЕслиСпецЛит() bool {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	if сам.цКласс == кСпецЛит {
		return true
	}
	return false
}

//ЕслиЦифра -- проверяет, что литера цифра
func (сам *тЛит) ЕслиЦифра() bool {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	if сам.цКласс == кЦифра {
		return true
	}
	return false
}

//Уст -- устанавливает хранимую литеру
func (сам *тЛит) Уст(пЛит СЛит) error {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	if пЛит == "" {
		return мФмт.Errorf("тЛит.Уст(): пЛит не может быть пустой\n")
	}
	if мСтр.Contains(стрБуквыВсе, string(пЛит)) {
		сам.цКласс = кБуква
	} else if мСтр.Contains(стрСпецЛит, string(пЛит)) {
		сам.цКласс = кСпецЛит
	} else if мСтр.Contains(стрЦифры, string(пЛит)) {
		сам.цКласс = кЦифра
	} else {
		return мФмт.Errorf("тЛит.Уст(): ОШИБКА неизвестный класс литеры, пЛит=[%v]\n", пЛит)
	}
	сам.лит = пЛит
	return nil
}

//Лит -- возвращает хранимую литеру
func (сам *тЛит) Лит() СЛит {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	return сам.лит
}

func (сам *тЛит) String() string {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	return мФмт.Sprint(сам.лит)
}
