package пакСтрПоз

/*
	Модуль предоставляет тип для операций с позицией в строке исходника
*/

import (
	мФмт "fmt"
	мСинх "sync"
)

//ССтрПоз -- специальный целочисленный тип для хранения позиции в строке исходника
type ССтрПоз int

//ИСтрПоз -- эксопртируемый интерфейс для операций с позицией в строке исходника
type ИСтрПоз interface {
	Уст(ССтрПоз) error
	Знач() ССтрПоз
	String() string
}

//ИСтрПозИзм -- эксопртируемый интерфейс для операций с позицией в строке исходника с изменениями
type ИСтрПозИзм interface {
	ИСтрПоз
	Доб()
	Сброс()
}

//Тип для операций с позицией в строке исходника
type тСтрПоз struct {
	знач   ССтрПоз
	стрПоз string
	блок   мСинх.Mutex
}

//СтрПозНов -- возвращает ссылку на ИСтрПоз
func СтрПозНов() (поз ИСтрПоз, ош error) {
	поз, ош = СтрПозИзмНов()
	return поз, ош
}

//СтрПозИзмНов -- возвращает ссылку на ИСтрПозИзм
func СтрПозИзмНов() (поз ИСтрПозИзм, ош error) {
	_поз := &тСтрПоз{}
	if _поз == nil {
		return nil, мФмт.Errorf("СтрПозИзмНов(): нет памяти на позицию в строке?\n")
	}
	_поз.стрПоз = "0"
	return _поз, nil
}

func (сам *тСтрПоз) Уст(пПоз ССтрПоз) error {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	if сам.знач != 0 {
		return мФмт.Errorf("тСтрПоз.Уст(): ОШИБКА номер позиции уже установлен, знач=[%v], пПоз=[%v]\n", сам.знач, пПоз)
	}
	if пПоз < 0 {
		return мФмт.Errorf("тСтрПоз.Уст(): ОШИБКА значение меньше (0), пПоз=[%v]\n", пПоз)
	}
	сам.знач = пПоз
	сам.стрПоз = мФмт.Sprintf("%v", пПоз)
	return nil
}

func (сам *тСтрПоз) Знач() ССтрПоз {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	return сам.знач
}

func (сам *тСтрПоз) Доб() {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	сам.знач++
	сам.стрПоз = мФмт.Sprintf("%v", сам.знач)
}

func (сам *тСтрПоз) Сброс() {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	сам.знач=0
	сам.стрПоз = "0"
}

func (сам *тСтрПоз) String() string {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	return сам.стрПоз
}
