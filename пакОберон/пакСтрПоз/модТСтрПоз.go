package пакСтрПоз

/*
	Модуль предоставляет тип для операций с позицией в строке исходника
*/

import (
	мФмт "fmt"
	мСинх "sync"
)

//ССтрПоз -- специальный целочисленный тип для хранения позиции в строке исходника
type ССтрПоз int

//ИСтрПоз -- эксопртируемый интерфейс для операций с позицией в строке исходника
type ИСтрПоз interface {
	Знач() ССтрПоз
	String() string
	ИнитУст(ССтрПоз) error
}

//ИСтрПозИзм -- эксопртируемый интерфейс для операций с позицией в строке исходника с изменениями
type ИСтрПозИзм interface {
	ИСтрПоз
	Уст(ССтрПоз) error
	Доб()
	Сброс()
}

//Тип для операций с позицией в строке исходника
type тСтрПоз struct {
	знач   ССтрПоз
	стрПоз string
	блок   мСинх.Mutex
	бУст   bool //Признак установленности для неизменяемой позиции
}

//СтрПозНов -- возвращает ссылку на ИСтрПоз
func СтрПозНов() (поз ИСтрПоз, ош error) {
	_поз := &тСтрПоз{}
	if _поз == nil {
		return nil, мФмт.Errorf("СтрПозНов(): нет памяти на позицию в строке?\n")
	}
	_поз.стрПоз = "0"
	return _поз, nil
}

//СтрПозИзмНов -- возвращает ссылку на ИСтрПозИзм
func СтрПозИзмНов() (поз ИСтрПозИзм, ош error) {
	_поз, ош := СтрПозНов()
	if ош != nil {
		return nil, мФмт.Errorf("СтрПозНовИзм(): ОШИБКА при создании имзеняемой позиции в строке\n\t%v", ош)
	}
	поз, ок := _поз.(ИСтрПозИзм)
	if !ок {
		return nil, мФмт.Errorf("СтрПозНовИзм(): ОШИБКА при преобразовании фиксированного ИСтрПоз в ИСтрПозИзм\n")
	}
	return поз, nil
}

//Одноразовая функция установки, блокировка местами есть на всякий случай, хот это и кривое решение
func (сам *тСтрПоз) ИнитУст(пПоз ССтрПоз) (ош error) {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	if сам.бУст {
		return мФмт.Errorf("тСтрПоз._Уст(): ОШИБКА номер позиции уже установлен, знач=[%v], пПоз=[%v]\n", сам.знач, пПоз)
	}
	if ош = сам._Уст(пПоз); ош != nil {
		return мФмт.Errorf("тСтрПоз._Уст(): ОШИБКА при установке значения\n\t%v", ош)
	}
	сам.бУст = true
	return nil
}

//Многоразовая функция установки
func (сам *тСтрПоз) Уст(пПоз ССтрПоз) error {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	return сам._Уст(пПоз)
}

//Потокобезопасная установка
func (сам *тСтрПоз) _Уст(пПоз ССтрПоз) error {
	if пПоз < 0 {
		return мФмт.Errorf("тСтрПоз.Уст(): ОШИБКА значение меньше (0), пПоз=[%v]\n", пПоз)
	}
	сам.знач = пПоз
	сам.стрПоз = мФмт.Sprintf("%v", пПоз)
	return nil
}

func (сам *тСтрПоз) Знач() ССтрПоз {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	return сам.знач
}

func (сам *тСтрПоз) Доб() {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	сам.знач++
	сам.стрПоз = мФмт.Sprintf("%v", сам.знач)
}

func (сам *тСтрПоз) Сброс() {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	сам.знач = 0
	сам.стрПоз = "0"
}

func (сам *тСтрПоз) String() string {
	defer сам.блок.Unlock()
	сам.блок.Lock()
	return сам.стрПоз
}
