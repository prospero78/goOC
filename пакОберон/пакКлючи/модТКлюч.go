package пакКлючи

/*
	Модуль предоставляет специальный тип для обработки ключевого(предопределённого) слова.
	У одного ключа может быть несколько синонимов, но как минимум один
*/

import (
	мФмт "fmt"
	мИнт "github.com/prospero78/goOC/пакОберон/пакИнтерфейсы"
)

//ТКлюч -- предоставляет обработку ключевых (предопределённых) слов
type ТКлюч struct {
	спрКлючи map[int]мИнт.СКлюч //Синонимы ключевого слова
}

//КлючНов -- возвращает ссылку на новое ключевое слово
func КлючНов(пКлюч мИнт.СКлюч) (ключ *ТКлюч, ош error) {
	ключ = &ТКлюч{}
	if ключ == nil {
		return nil, мФмт.Errorf("КлючНов(): нет памяти под новое ключевое слово?")
	}
	ключ.спрКлючи = make(map[int]мИнт.СКлюч)
	if ош = ключ.Доб(пКлюч); ош != nil {
		return nil, мФмт.Errorf("КлючНов(): ошибка при установке ключевого слова\n\t%v", ош)
	}
	return ключ, nil
}

//Доб -- добавляет синоним в набор ключевых слов
func (сам *ТКлюч) Доб(пКлюч мИнт.СКлюч) error {
	if пКлюч == "" {
		return мФмт.Errorf("ТСловоКлюч.Доб(): пКлюч не может быть пустым\n")
	}
	сам.спрКлючи[len(сам.спрКлючи)] = пКлюч
	return nil
}

//ЕслиСовпал -- проверяет совпадение ключевого слова с хранимым набором
func (сам *ТКлюч) ЕслиСовпал(пКлюч мИнт.СКлюч) (ок bool, ош error) {
	if пКлюч == "" {
		return false, мФмт.Errorf("ТСловоКлюч.ЕслиСовпал(): пКлюч не может быть пустым\n")
	}
	//Перебрать в цикле ключевое слово
	for _, ключ := range сам.спрКлючи {
		if пКлюч == ключ {
			return true, nil
		}
	}
	return false, nil
}

//Синонимы -- возвращает синонимы ключа
func (сам *ТКлюч) Синонимы() map[int]мИнт.СКлюч {
	return сам.спрКлючи
}
