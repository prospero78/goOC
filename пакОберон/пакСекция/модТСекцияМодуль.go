package пакСекция

/*
	Предоставляет возможность сканеру секций определеить правильно ли
	описан модуль.
*/

import (
	мИнт "github.com/prospero78/goOC/пакОберон/пакИнтерфейсы"
	мИф "github.com/prospero78/goOC/пакОберон/пакИсходникФайл"
	мКлючи "github.com/prospero78/goOC/пакОберон/пакКлючи"
	мКонс "github.com/prospero78/goOC/пакОберон/пакКонсоль"
	мСкан "github.com/prospero78/goOC/пакОберон/пакСканер"
	мСлово "github.com/prospero78/goOC/пакОберон/пакСлово"

	//мСлово "../пакСлово"
	мФмт "fmt"
)

//СМодульИмя -- специальный строковый тип для хранения имени модуля
type СМодульИмя string

//ССловоНомерМодуль -- специальный целочисленный тип для хранения номера слова модуля
type ССловоНомерМодуль int

//ТСекцияМодуль -- предоставляет тип, содержащий слова модуля
type ТСекцияМодуль struct {
	*ТСекция
	модульИмя     СМодульИмя
	слово         мСлово.ИСлово // слово в котором хранится имя модуля
	сканер        мСкан.ИСканер
	секцияКоммент ИСекцияКоммент //Секция комментариев
	секцияИмпорт  ИСекцияИмпорт
}

//МодульНов -- возвращает на новый ТСекцияМодуль
func МодульНов() (модуль *ТСекцияМодуль, ош error) {
	мКонс.Конс.Отладить("МодульНов()")
	секция, ош := СекцияНов("МОДУЛЬ")
	if ош != nil {
		return nil, мФмт.Errorf("МодульНов(): ошибка при создании базовой секции\n\t%v", ош)
	}
	модуль = &ТСекцияМодуль{ТСекция: секция}
	if модуль == nil {
		return nil, мФмт.Errorf("МодульНов(): нет памяти на модуль?\n")
	}
	if модуль.сканер, ош = мСкан.СканерНов(); ош != nil {
		return nil, мФмт.Errorf("МодульНов(): ошибка при создании сканера модуля\n\t%v", ош)
	}
	if модуль.секцияКоммент, ош = СекцияКомментНов(); ош != nil {
		return nil, мФмт.Errorf("МодульНов(): ошибка при создании секции комментариев\n\t%v", ош)
	}
	if модуль.секцияИмпорт, ош = СекцияИмпортНов(); ош != nil {
		return nil, мФмт.Errorf("МодульНов(): ошибка при создании секции импорта\n\t%v", ош)
	}
	return модуль, nil
}

//Обработать -- обеспечивает выделение слов модуля
func (сам *ТСекцияМодуль) Обработать(пФайлИмя мИф.СФайлИсхИмя) (ош error) {
	мКонс.Конс.Отладить("ТСекцияМодуль.Обработать()")
	if ош = сам.сканер.Обработать(пФайлИмя); ош != nil {
		return мФмт.Errorf("ТСекцияМодуль.Обработать(): ошибка при работе сканера\n\t%v", ош)
	}
	сам.словаМодуля = сам.сканер.Слова()
	мФмт.Printf("Всего слов в модуле [%v]\n", len(сам.СловаМодуля()))

	//Вывести все комментарии в отдельную секцию. Там могут быть различные опции
	if ош = сам.секцияКоммент.СловаУст(сам.СловаМодуля()); ош != nil {
		return мФмт.Errorf("ТСекцияМодуль.Обработать(): ошибка при установке слов секции комментариев\n\t%v", ош)
	}
	if ош = сам.секцияКоммент.Обработать(); ош != nil {
		return мФмт.Errorf("ТСекцияМодуль.Обработать(): ошибка при обработке секции комментариев\n\t%v", ош)
	}
	сам.СловаУст(сам.секцияКоммент.СловаМодуля())
	мФмт.Printf("\tВсего слов в комментариях: [%v]\n", len(сам.секцияКоммент.СловаКоммент()))

	if ош = сам._МодульНачалоПроверить(); ош != nil {
		return мФмт.Errorf("ТСекцияМодуль.Обработать(): ошибка при поиске начала модуля\n\t%v", ош)
	}
	if ош = сам._ИмяПроверить(); ош != nil {
		return мФмт.Errorf("ТСекцияМодуль.Обработать(): ошибка при поиске имени модуля\n\t%v", ош)
	}
	if ош = сам._РазделительПроверить(); ош != nil {
		return мФмт.Errorf("ТСекцияМодуль.Обработать(): ошибка при поиске разделителя заголовка модуля\n\t%v", ош)
	}
	словоКонец, ош := сам._МодульКонецНайти()
	if ош != nil {
		return мФмт.Errorf("ТСекцияМодуль.Обработать(): ошибка при поиске конца модуля\n\t%v", ош)
	}
	if ош = сам._МодульКонецОбрезать(словоКонец); ош != nil {
		return мФмт.Errorf("ТСекцияМодуль.Обработать(): ошибка при обрезке слов окончания модуля\n\t%v", ош)
	}
	if ош = сам._МодульОдинПроверить(); ош != nil {
		return мФмт.Errorf("ТСекцияМодуль.Обработать(): ошибка при поиске единственного MODULE\n\t%v", ош)
	}
	мФмт.Printf("Всего слов в модуле после обработки > [%v]\n", len(сам.СловаМодуля()))
	{ //Теперь проверим секцию импорта
		сам.секцияИмпорт.СловаУст(сам.СловаМодуля())
		if ош = сам.секцияИмпорт.Обработать(); ош != nil {
			return мФмт.Errorf("ТСекцияМодуль.Обработать(): ошибка при обработке импорта\n\t%v", ош)
		}
		сам.словаМодуля = сам.секцияИмпорт.СловаМодуля()
	}
	return nil
}

// Проверяет имя модуля в тексте
func (сам *ТСекцияМодуль) _ИмяПроверить() (ош error) {
	мКонс.Конс.Отладить("ТСекцияМодуль._ИмяПроверить()")
	слово := сам.СловаМодуля()[0]
	//мКонс.Конс.Отладить("Проверка имени модуля: \"" + слово.Строка() + "\"")
	if слово.ЕслиИмяСтрого() {
		сам.модульИмя = СМодульИмя(слово.Слово())
	} else {
		стрСлово := слово.Слово()
		стрИсх := слово.Строка()
		return мФмт.Errorf("ТСекцияМодуль._ИмяПроверить(): такое имя модуля запрещено, имя=[%v], строка=[%v]\n", стрСлово, стрИсх)
	}
	if сам.словаМодуля, ош = СловаМодуляОбрезать(сам.СловаМодуля()); ош != nil {
		return мФмт.Errorf("ТСекцияМодуль._ИмяПроверить(): ошибка при обрезке слов модуля\n\t%v", ош)
	}
	return nil
}

// Проверяет разделитель после имени модуля в начале
func (сам *ТСекцияМодуль) _РазделительПроверить() (ош error) {
	мКонс.Конс.Отладить("ТСекцияМодуль._РазделительПроверить()")
	слово := сам.СловаМодуля()[0]
	стрСлово := слово.Слово()
	стрИсх := слово.Строка()
	ок, ош := мКлючи.Ключи.Проверить(";", мКлючи.СКлюч(стрСлово))
	if ош != nil {
		return мФмт.Errorf("ТСекцияМодуль._РазделительПроверить(): ошибка при проверке разделителя модуля\n\t%v", ош)
	}
	if !ок {
		return мФмт.Errorf("ТСекцияМодуль._РазделительПроверить(): ошибка в окончании названия модуля, слово=[%v], строка=[%v]\n",
			стрСлово, стрИсх)
	}
	if сам.словаМодуля, ош = СловаМодуляОбрезать(сам.СловаМодуля()); ош != nil {
		return мФмт.Errorf("ТСекцияМодуль._РазделительПроверить(): ошибка пи обрезании слов модуля\n\t%v", ош)
	}
	//Теперь первое слово указывает на следующую интсрукцию
	return nil
}

func (сам *ТСекцияМодуль) _МодульКонецНайти() (словоНомерКонец ССловоНомерМодуль, ош error) {
	мКонс.Конс.Отладить("ТСекцияМодуль._МодульКонецНайти()")
	цСчётОбр := ССловоНомерМодуль(len(сам.СловаМодуля()) - 1)
	for цСчётОбр = ССловоНомерМодуль(len(сам.СловаМодуля()) - 1); цСчётОбр >= 0; цСчётОбр-- {
		словоТочка := сам.СловаМодуля()[цСчётОбр]
		// Нашли конечную точку?
		стрТочка := словоТочка.Слово()
		ок, ош := мКлючи.Ключи.Проверить(".", мКлючи.СКлюч(стрТочка))
		if ош != nil {
			return -1, мФмт.Errorf("ТСекцияМодуль._КонецМодульНайти(): 1 ошибка при поиске конца модуля\n\t%v", ош)
		}
		if !ок {
			continue
		}
		//Попытка найти имя модуля
		словоИмя := сам.СловаМодуля()[цСчётОбр-1]
		стрИмя := словоИмя.Слово()
		if СМодульИмя(стрИмя) != сам.МодульИмя() {
			цСчётОбр--
			continue
		}
		// Попытка найти END. КсМодуль содержит множество слов
		словоКонец := сам.СловаМодуля()[цСчётОбр-2]
		стрКонец := словоКонец.Слово()
		ок, ош = мКлючи.Ключи.Проверить("END", мИнт.СКлюч(стрКонец))
		if ош != nil {
			return -1, мФмт.Errorf("ТСекцияМодуль._КонецМодульНайти(): 2 ошибка при поиске конца модуля\n\t%v", ош)
		}
		if !ок {
			цСчётОбр -= 2
			continue
		}
		//Все три элемента найдены, надо оборвать поиск по диапазону слов
		return цСчётОбр, nil
	}
	return -1, мФмт.Errorf("ТСекцияМодуль._КонецМодуль_Найти(): нет завершающей точки в модуле")
}

// Всё, что за END <name_module>.-- загнать в секцию комментариев
func (сам *ТСекцияМодуль) _МодульКонецОбрезать(пСчётОбр ССловоНомерМодуль) error {
	if !((0 <= пСчётОбр) && (пСчётОбр+2 <= мИнт.ССловоНомерМодуль(len(сам.словаМодуля)-1))) {
		return мФмт.Errorf("ТСекцияМодуль._МодульКонецобрезать(): нарушена структура модуля?\n")
	}
	//Всё, что за точкой -- отправить в комментарии
	индекс := ССловоНомерМодуль(0)
	for индекс = ССловоНомерМодуль((len(сам.словаМодуля))); индекс >= пСчётОбр; индекс-- {
		if индекс > пСчётОбр+2 {
			сам.секцияКоммент.СловоДоб(сам.словаМодуля[индекс])
		}
		delete(сам.словаМодуля, индекс)
	}
	return nil
}

// Проверяет, что MODULE реально один в модуле, первый уже отброшен
func (сам *ТСекцияМодуль) _МодульОдинПроверить() (ош error) {
	мКонс.Конс.Отладить("ТМодТСекцияМодульуль._МодульОдинПроверить()")
	for адр := 0; адр < len(сам.СловаМодуля()); адр++ {
		ключ := сам.СловаМодуля()[мИнт.ССловоНомерМодуль(адр)]
		//мФмт.Printf("%v\n", ключ)
		стрСлово := мИнт.СКлюч(ключ.Слово())
		ок, ош := мКлючи.Ключи.Проверить("MODULE", стрСлово)
		if ош != nil {
			return мФмт.Errorf("ТСекцияМодуль._МодульОдинПроверить(): ошибка при проверке единственного MODULE\n\t%v", ош)
		}
		if ок { //Найдено MODULE
			return мФмт.Errorf("ТСекцияМодуль._МодульОдинПроверить(): MODULE встречается больше одного раза")
		}
	}
	return nil
}

// Проверяет, что модуль начинается правильно
func (сам *ТСекцияМодуль) _МодульНачалоПроверить() (ош error) {
	мКонс.Конс.Отладить("ТСекцияМодуль._МодульНачало_Проверить()")
	словоМОДУЛЬ := сам.СловаМодуля()[0]
	//Проверить, что это ключевое слово МОДУЛЬ
	ок, ош := мКлючи.Ключи.Проверить("MODULE", мИнт.СКлюч(словоМОДУЛЬ.Слово()))
	if ош != nil {
		return мФмт.Errorf("ТСекцияМодуль._МодульНачалоПроверить(): ошибка при проверке слова\n\t%v", ош)
	}
	if !ок {
		return мФмт.Errorf("ТСекцияМодуль._МодульНачалоПроверить(): нет начала модуля, MODULE=\"%v\"\n\t%v", словоМОДУЛЬ, ош)
	}
	сам.модульИмя = мИнт.СМодульИмя(словоМОДУЛЬ.Слово())
	if сам.словаМодуля, ош = мИнт.СловаМодуляОбрезать(сам.СловаМодуля()); ош != nil {
		return мФмт.Errorf("ТСекцияМодуль._МодульНачалоПроверить(): ошибка при обрезании слов модуля\n\t%v", ош)
	}
	//Теперь следующее слово имя. обрабатывается уровнем выше.
	return nil
}

//МодульИмя -- возвращает список слов модуля
func (сам *ТСекцияМодуль) МодульИмя() СМодульИмя {
	return сам.модульИмя
}
