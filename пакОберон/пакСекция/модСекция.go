package пакСекция

// модСекция

/*
	Модуль предоставляет тип секции (общий для всех секций)
*/

import (
	мФмт "fmt"
	мИнт "../пакИнтерфейсы"
)

//ТСекция -- базовый тип для всех секций
type ТСекция struct {
	слова  map[int]мИнт.ИСлово
	стрТип string //Хранит имя секциии (для модуля -- "МОДУЛЬ")
}

//СекцияНов -- создаёт и возвращает новый объект типа секции
func СекцияНов(пИмя string) (секция *ТСекция, ош error) {
	секция = &ТСекция{стрТип: пИмя}
	if секция==nil{
		return nil, мФмт.Errorf("СекцияНов(): нет памяти под новую секцию?\n")
	}
	секция.слова=make(map[int]мИнт.ИСлово)
	return секция, nil
}

// Тип -- возвращает тип секции
func (сам *ТСекция) Тип() string {
	return сам.стрТип
}

// Слова -- возвращает список слов секции (модуль тоже своего рода секция)
func (сам *ТСекция) Слова() map[int]мИнт.ИСлово {
	return сам.слова
}

// СловаУст -- устанавливает список слов секции (модуль тоже своего рода секция)
func (сам *ТСекция) СловаУст(пСлова map[int]мИнт.ИСлово) {
	сам.слова = пСлова
}

// СловаПечать -- Печатает все слова секции
func (сам *ТСекция) СловаПечать() (ош error) {
	итер := 0
	стр := ""
	for _, слово := range сам.слова {
		стрСлово := слово.Строка()
		с := мФмт.Sprintf("%v) %10.12v    ", слово.Номер(), стрСлово)
		стр = стр + с
		итер++
		if итер == 3 {
			стр += "\n"
			мФмт.Printf(стр)
			стр = ""
			итер = 0
		}
	}
	return nil
}

//КонецУст -- Устанавливает слово-маркер -- конец секции
func (сам *ТСекция) КонецУст() {

}

//СловаСекцииРазделить -- разделяет слова своей секции и слова модуля (оставшиеся)
func (сам *ТСекция) СловаСекцииРазделить() {

}
