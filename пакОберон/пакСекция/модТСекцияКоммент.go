package пакСекция

// модКоммент

/*
	Выделение комментариев необходимо для (возможного) дальнейшего анализа
	комментариев на наличие опций компилятора.
	Это псевдосекция.
*/

import (
	мФмт "fmt"
	мИнт "github.com/prospero78/goOC/пакОберон/пакИнтерфейсы"
	мКонс "github.com/prospero78/goOC/пакОберон/пакКонсоль"
)

//ТСекцияКоммент -- тип псевдосекции со словами комментария
type ТСекцияКоммент struct {
	*ТСекция
	словаКоммент map[мИнт.ССловоНомерКоммент]мИнт.ИСлово
}

//СекцияКомментНов -- возвращает новый экземпляр типа псевдосекции комментариев
func СекцияКомментНов() (коммент *ТСекцияКоммент, ош error) {
	мКонс.Конс.Отладить("СекцияКомментНов()")
	секция, ош := СекцияНов("КОММЕНТ")
	if ош != nil {
		return nil, мФмт.Errorf("СекцияКомментНов(): ошибка при создании базовой секции комментариев\n\t%v", ош)
	}
	коммент = &ТСекцияКоммент{ТСекция: секция}
	if коммент == nil {
		return nil, мФмт.Errorf("СекцияКомментНов(): нет памяти на секцию комментариев?\n")
	}
	коммент.словаКоммент = make(map[мИнт.ССловоНомерКоммент]мИнт.ИСлово)
	return коммент, nil
}

//Обработать -- главный обработчик секции
func (сам *ТСекцияКоммент) Обработать() (ош error) {
	цУровень := 0
	спрКоммент := make(map[мИнт.ССловоНомерКоммент]мИнт.ИСлово)
	спрМодуль := make(map[мИнт.ССловоНомерМодуль]мИнт.ИСлово)
	адрМодуль := мИнт.ССловоНомерМодуль(0)
	адрКоммент := мИнт.ССловоНомерКоммент(0)
	цНомерМодуль := мИнт.ССловоНомерМодуль(0)
	for цНомерМодуль = 0; int(цНомерМодуль) < len(сам.СловаМодуля()); цНомерМодуль++ {
		слово := сам.СловаМодуля()[цНомерМодуль]
		//пакКонс.Конс.Отладить("Слово: " + слово.Строка())
		стрСлово := слово.Слово()
		if стрСлово == "(*" {
			цУровень++
			continue
			//пакКонс.Конс.Отладить("Уровень комментов: " + мФмт.Sprintf("%v", цУровень))
		} else if стрСлово == "*)" {
			цУровень--
			continue
		}
		//Заполнение словарей в зависимости от уровня комментариев
		if цУровень == 0 {
			спрМодуль[адрМодуль] = слово
			адрМодуль++
		} else {
			спрКоммент[адрКоммент] = слово
			адрКоммент++
		}
	}
	if цУровень != 0 {
		return мФмт.Errorf("ТуКоммент.Обработать(): уровень комментариев на сбалансирован, уровень = %v", цУровень)
	}
	//мКонс.Конс.Отладить(мФмт.Sprintf("Итоговый уровень комментов > [%v].   Всего слов > [%v].", цУровень, len(спрКоммент)))
	//мКонс.Конс.Отладить(мФмт.Sprintf("Слов модуля: %v   Всего слов в модуле: %v", len(спрМодуль), len(спрКоммент)+len(спрМодуль)))
	сам.словаКоммент = спрКоммент
	сам.словаМодуля = спрМодуль
	return nil
}

// СловаКомментПечать -- Печатает все слова секции
func (сам *ТСекцияКоммент) СловаКомментПечать() (ош error) {
	итер := 0
	стр := ""
	for _, слово := range сам.словаКоммент {
		стрСлово := слово.Строка()
		с := мФмт.Sprintf("%v) %10.12v    ", слово.Номер(), стрСлово)
		стр = стр + с
		итер++
		if итер == 3 {
			стр += "\n"
			мФмт.Printf(стр)
			стр = ""
			итер = 0
		}
	}
	return nil
}

// СловаКоммент -- Возвращает слова импорта
func (сам *ТСекцияКоммент) СловаКоммент() (слова map[мИнт.ССловоНомерКоммент]мИнт.ИСлово) {
	return сам.словаКоммент
}

//СловоДоб -- добавляет слово в секцию комментариев. Вызывается, когда
//за окончанием модуля есть текст. Может быть полезно
func (сам *ТСекцияКоммент) СловоДоб(пСлово мИнт.ИСлово) {
	сам.словаКоммент[мИнт.ССловоНомерКоммент(len(сам.словаКоммент))] = пСлово
}
