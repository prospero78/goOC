package пакИмпорт

// модИмпорт

/*
	Модуль предоставляет тип для анализа секции импорта
*/

import (
	пакКонс "../../пакКонсоль"
	пакСлово "../../пакСлово"
	пакСекция "../пакСекция"
	пакФмт "fmt"
)

//ТИмпорт -- тип выделяети хранит слова импорта
type ТИмпорт struct {
	секция *пакСекция.ТСекция
	модуль *пакСекция.ТСекция
}

//ИмпортНов -- Создаёт и возвращает новый экземпляр для выделения слов импорта модуля
func ИмпортНов() (импорт *ТИмпорт, ош error) {
	пакКонс.Конс.Отладить("ИмпортНов()")
	секция := пакСекция.Новый("ИМПОРТ")
	модуль := пакСекция.Новый("МОДУЛЬ")
	импорт = &ТИмпорт{
		секция: секция,
		модуль: модуль,
	}
	return импорт, ош
}

//Обработать -- главная функция обработки секции импорт
func (сам *ТИмпорт) Обработать(пСловаМодуля []*пакСлово.ТСлово) (ош error) {
	пакКонс.Конс.Отладить("ТИмпорт.Обработать()")
	сам.секция.СловаУст(пСловаМодуля)
	сам.модуль.СловаУст(пСловаМодуля)
	if сам._ЕслиИмпорт() {
		if ош := сам._ЕслиИмпортОдин(); ош != nil {
			ош = пакФмт.Errorf("ТуИмпорт.Обработать(): ошибка при проверке одной секции импорт\n\t%v", ош)
			return ош
		}
		if ош := сам._ЕслиИмпортОграничен(); ош == nil {
			сам.секция.СловаСекцииРазделить()
			return nil
		}
		ош = пакФмт.Errorf("ТуИмпорт.Обработать(): ошибка при проверке ограничения секции импорта\n\t%v", ош)
		return ош
	}
	panic("ТуИмпорт.Обработать(): 1 -- до этого места код дойти не должен")
}

func (сам *ТИмпорт) _ЕслиИмпортОдин() (ош error) {
	пакКонс.Конс.Отладить("ТИмпорт._ЕслиИмпортОдин()")
	счётИмпорт := 0
	словоНом := 0
	словаВсего := len(сам.модуль.Слова())
	for словоНом < словаВсего {
		слово := сам.модуль.Слова()[словоНом]
		словоНом++
		for индекс := range пакСлово.КсИмпорт {
			стрИмпорт, _ := слово.Строка()
			if стрИмпорт == пакСлово.КсИмпорт[индекс] {
				счётИмпорт++
			}
			if счётИмпорт > 1 {
				стрИсх, _ := слово.СтрИсх()
				ош = пакФмт.Errorf("пакСекции.пакИмпорт.ТуИмпорт._ЕслиИмпортОдин(): IMPORT два раза в одном модуле запрещён\n\t%v", стрИсх)
				return ош
			}
		}
	}

	return nil
}
func (сам *ТИмпорт) _ЕслиИмпорт() (рез bool) {
	слово := сам.модуль.Слова()[0]
	//Цикл по словарю слова IMPORT
	for _, слИмпорт := range пакСлово.КсИмпорт {
		//Проверка на все возможные значения
		стрИмпорт, _ := слово.Строка()
		if стрИмпорт == слИмпорт {
			рез = true
			сам.секция.СловаОбрезать()
		}
	}
	return рез
}

func (сам *ТИмпорт) _ЕслиИмпортОграничен() (ош error) {
	Дальше := func(слово *пакСлово.ТСлово) bool {
		стр, _ := слово.Строка()
		return стр != ";"
	}
	цСловоНом := 0
	слово := сам.модуль.Слова()[0]
	for Дальше(слово) && (цСловоНом < len(сам.модуль.Слова())) {
		цСловоНом++
		слово = сам.модуль.Слова()[цСловоНом]
	}
	if Дальше(слово) {
		ош = пакФмт.Errorf("ТуИмпорт._ЕслиИмпортОграничен(): секция импорта ничем не ограничена")
		return ош
	}
	сам.секция.КонецУст()
	return ош
}

//СловаМодуля -- возвращает слова модуля
func (сам *ТИмпорт) СловаМодуля() (слова []*пакСлово.ТСлово) {
	return сам.модуль.Слова()
}

// СловаСекции -- Возвращает слова импорта
func (сам *ТИмпорт) СловаСекции() (слова []*пакСлово.ТСлово) {
	return сам.секция.Слова()
}

//СловаИмпортПечать -- печатает слова в секции импорта
func (сам *ТИмпорт) СловаИмпортПечать() {
	сам.секция.СловаПечать()
}
