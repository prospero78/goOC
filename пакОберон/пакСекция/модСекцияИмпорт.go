package пакСекция

// модИмпорт

/*
	Модуль предоставляет тип для анализа секции импорта
*/

import (
	мИнт "../пакИнтерфейсы"
	пакКонс "../пакКонсоль"
	пакСлово "../пакСлово"
	мФмт "fmt"
)

//ТИмпорт -- тип выделяети хранит слова импорта
type ТИмпорт struct {
	секция *ТСекция
	модуль *ТСекция
}

//ИмпортНов -- Создаёт и возвращает новый экземпляр для выделения слов импорта модуля
func ИмпортНов() (импорт *ТИмпорт, ош error) {
	пакКонс.Конс.Отладить("ИмпортНов()")
	секция, ош := СекцияНов("ИМПОРТ")
	if ош != nil {
		return nil, мФмт.Errorf("ИмпортНов(): ошибка при создании секции импорта\n\t%v", ош)
	}
	модуль, ош := СекцияНов("МОДУЛЬ")
	if ош != nil {
		return nil, мФмт.Errorf("ИмпортНов(): ошибка при создании секции модуля\n\t%v", ош)
	}
	импорт = &ТИмпорт{
		секция: секция,
		модуль: модуль,
	}
	return импорт, ош
}

//Обработать -- главная функция обработки секции импорт
func (сам *ТИмпорт) Обработать(пСловаМодуля map[int]мИнт.ИСлово) (ош error) {
	пакКонс.Конс.Отладить("ТИмпорт.Обработать()")
	сам.секция.СловаУст(пСловаМодуля)
	сам.модуль.СловаУст(пСловаМодуля)
	if сам._ЕслиИмпорт() {
		if ош := сам._ЕслиИмпортОдин(); ош != nil {
			ош = мФмт.Errorf("ТуИмпорт.Обработать(): ошибка при проверке одной секции импорт\n\t%v", ош)
			return ош
		}
		if ош := сам._ЕслиИмпортОграничен(); ош == nil {
			сам.секция.СловаСекцииРазделить()
			return nil
		}
		ош = мФмт.Errorf("ТуИмпорт.Обработать(): ошибка при проверке ограничения секции импорта\n\t%v", ош)
		return ош
	}
	panic("ТуИмпорт.Обработать(): 1 -- до этого места код дойти не должен")
}

func (сам *ТИмпорт) _ЕслиИмпортОдин() (ош error) {
	пакКонс.Конс.Отладить("ТИмпорт._ЕслиИмпортОдин()")
	счётИмпорт := 0
	словоНом := 0
	словаВсего := len(сам.модуль.Слова())
	for словоНом < словаВсего {
		слово := сам.модуль.Слова()[словоНом]
		словоНом++
		for индекс := range пакСлово.КсИмпорт {
			стрИмпорт := слово.Слово()
			if стрИмпорт == пакСлово.КсИмпорт[индекс] {
				счётИмпорт++
			}
			if счётИмпорт > 1 {
				стрИсх := слово.Строка()
				ош = мФмт.Errorf("пакСекции.пакИмпорт.ТуИмпорт._ЕслиИмпортОдин(): IMPORT два раза в одном модуле запрещён\n\t%v", стрИсх)
				return ош
			}
		}
	}

	return nil
}
func (сам *ТИмпорт) _ЕслиИмпорт() (рез bool) {
	слово := сам.модуль.Слова()[0]
	//Цикл по словарю слова IMPORT
	for _, слИмпорт := range пакСлово.КсИмпорт {
		//Проверка на все возможные значения
		стрИмпорт := слово.Слово()
		if стрИмпорт == слИмпорт {
			рез = true
			if слова, ош := мИнт.СловаОбрезать(сам.секция.Слова()); ош != nil {
				panic(мФмт.Errorf("ТИмпорт._ЕслиИмпорт(): ошибка при обрезке слов\n\t%v", ош))
			} else {
				сам.секция.СловаУст(слова)
			}

		}
	}
	return рез
}

func (сам *ТИмпорт) _ЕслиИмпортОграничен() (ош error) {
	Дальше := func(слово мИнт.ИСлово) bool {
		стр := слово.Строка()
		return стр != ";"
	}
	цСловоНом := 0
	слово := сам.модуль.Слова()[0]
	for Дальше(слово) && (цСловоНом < len(сам.модуль.Слова())) {
		цСловоНом++
		слово = сам.модуль.Слова()[цСловоНом]
	}
	if Дальше(слово) {
		ош = мФмт.Errorf("ТуИмпорт._ЕслиИмпортОграничен(): секция импорта ничем не ограничена")
		return ош
	}
	сам.секция.КонецУст()
	return ош
}

//СловаМодуля -- возвращает слова модуля
func (сам *ТИмпорт) СловаМодуля() (слова map[int]мИнт.ИСлово) {
	return сам.модуль.Слова()
}

// СловаСекции -- Возвращает слова импорта
func (сам *ТИмпорт) СловаСекции() (слова map[int]мИнт.ИСлово) {
	return сам.секция.Слова()
}

//СловаИмпортПечать -- печатает слова в секции импорта
func (сам *ТИмпорт) СловаИмпортПечать() {
	сам.секция.СловаПечать()
}
