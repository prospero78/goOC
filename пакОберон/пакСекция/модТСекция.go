package пакСекция

/*
	Модуль предоставляет тип секции (общий для всех секций).
	Секции бывают:
		TYPE
		CONST
		VAR
		PROCEDURE
		BEGIN
*/

import (
	мФмт "fmt"
	мКлючи "github.com/prospero78/goOC/пакОберон/пакКлючи"
)

//ССекцияТип -- специальный строковый тип для хранения типа секции
type ССекцияТип string

//ССловоНомерСекция -- специадбный целочисленный тип для хранения номера слова секции
type ССловоНомерСекция int

//ССловоНомерМодуль -- специальный целочисленный тип для хранения номера слова модуля
type ССловоНомерМодуль int

//ССловоНомерКоммент -- специальный целочисленный тип для хранения номера слова секции комментариев
type ССловоНомерКоммент int

//ССловоНомерИмпорт -- специальный целочисленный тип для хранения номера слова секции импорта
type ССловоНомерИмпорт int

//ИСекция -- базовый тип секции
type ИСекция interface {
	СловаМодуля() map[ССловоНомерМодуль]ИСлово
	//СловаСекции() map[ССловоНомерСекция]ИСлово // У каждого типа секции свой метод
	СловаУст(map[ССловоНомерМодуль]ИСлово) error
	СтрТип() ССекцияТип
}

//ТСекция -- базовый тип для всех секций
type ТСекция struct {
	словаМодуля map[мИнт.ССловоНомерМодуль]мИнт.ИСлово
	стрТип      мИнт.ССекцияТип //Хранит тип секциии (для модуля -- "МОДУЛЬ")
}

//СекцияНов -- создаёт и возвращает новый объект типа секции
func СекцияНов(пТип мИнт.ССекцияТип) (секция *ТСекция, ош error) {
	секция = &ТСекция{}
	if секция == nil {
		return nil, мФмт.Errorf("СекцияНов(): нет памяти под новую секцию?\n")
	}
	if ош = секция._ТипУст(пТип); ош != nil {
		return nil, мФмт.Errorf("СекцияНов(): ошибка при установке типа секции\n\t%v", ош)
	}
	секция.словаМодуля = make(map[мИнт.ССловоНомерМодуль]мИнт.ИСлово)
	return секция, nil
}

//Устанавливает тип секции в модуле. Вызывается один раз
func (сам *ТСекция) _ТипУст(пТип мИнт.ССекцияТип) (ош error) {
	if сам.стрТип != "" {
		return мФмт.Errorf("ТСекция._ТипУст(): тип секции уже установлен. тип=[%v], пТип=[%v]\n", сам.стрТип, пТип)
	}
	if пТип == "" {
		return мФмт.Errorf("ТСекция._ТипУст(): тип секции не может быть пустым, пТип=[%v]\n", пТип)
	}
	if ош = мКлючи.Ключи.СекцияТипПров(мИнт.СКлюч(пТип)); ош != nil {
		return мФмт.Errorf("ТСекция._ТипУст(): ошибка при проверке типа секции\n\t%v", ош)
	}
	return nil
}

//СтрТип -- возвращает тип секции (МОДУЛЬ, ИМПОРТ, КОММЕНТ и т.д.)
func (сам *ТСекция) СтрТип() мИнт.ССекцияТип {
	return сам.стрТип
}

// СловаМодуля -- возвращает список слов модуля
func (сам *ТСекция) СловаМодуля() map[мИнт.ССловоНомерМодуль]мИнт.ИСлово {
	return сам.словаМодуля
}

// СловаУст -- устанавливает список слов секции (модуль тоже своего рода секция)
func (сам *ТСекция) СловаУст(пСлова map[мИнт.ССловоНомерМодуль]мИнт.ИСлово) error {
	if пСлова == nil {
		return мФмт.Errorf("ТСекияя.словаУст(): пСлова не может быть nil\n")
	}
	сам.словаМодуля = пСлова
	return nil
}
