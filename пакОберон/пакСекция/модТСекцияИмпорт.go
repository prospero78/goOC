package пакСекция

/*
	Модуль предоставляет тип для анализа секции импорта
*/

import (
	мИнт "../пакИнтерфейсы"
	мКлюч "../пакКлючи"
	мКонс "../пакКонсоль"
	мСлово "../пакСлово"
	мФмт "fmt"
)

//ТСекцияИмпорт -- тип выделяети хранит слова импорта
type ТСекцияИмпорт struct {
	*ТСекция
	словаИмпорт map[мИнт.ССловоНомерИмпорт]мИнт.ИСлово
	словоКонец  мИнт.ССловоНомерМодуль //номер слова для ограничния секции импорта
}

//СекцияИмпортНов -- Создаёт и возвращает новый экземпляр для выделения слов импорта модуля
func СекцияИмпортНов() (импорт *ТСекцияИмпорт, ош error) {
	мКонс.Конс.Отладить("СекцияИмпортНов()")
	секция, ош := СекцияНов("ИМПОРТ")
	if ош != nil {
		return nil, мФмт.Errorf("СекцияИмпортНов(): ошибка при создании секции импорта\n\t%v", ош)
	}
	импорт = &ТСекцияИмпорт{
		ТСекция: секция,
	}
	импорт.словаИмпорт = make(map[мИнт.ССловоНомерИмпорт]мИнт.ИСлово)
	return импорт, ош
}

//Обработать -- главная функция обработки секции импорт
func (сам *ТСекцияИмпорт) Обработать() (ош error) {
	мКонс.Конс.Отладить("ТСекцияИмпорт.Обработать()")
	окИмп := false //Признак наличи импорта
	{              //Проверить есть ли импорт
		if окИмп, ош = сам._ЕслиИмпорт(); ош != nil {
			return мФмт.Errorf("ТСекцияИмпорт.Обработать(): ошибка при поиске начала секции импорта\n\t%v", ош)
		}
	}
	//Разобрать секцию импорта
	if окИмп { //ИМПОРТ есть, разобрать секцию импорта
		//Проверить на окончание импорта
		if ош = сам._ЕслиИмпортОграничен(); ош != nil {
			ош = мФмт.Errorf("ТСекцияИмпорт.Обработать(): ошибка при проверке ограничения секции импорта\n\t%v", ош)
			return ош
		}
		if ош = сам._СловаСекцииРазделить(); ош != nil {
			return мФмт.Errorf("ТСекцияИмпорт.Обработать(): ошибка при разделении слов секции ИМПОРТ и модуля\n\t%v", ош)
		}
		if ош := сам._ЕслиИмпортОдин(); ош != nil {
			ош = мФмт.Errorf("ТСекцияИмпорт.Обработать(): ошибка при проверке одной секции импорт\n\t%v", ош)
			return ош
		}
		//Теперь нужно разобрат ьвсе слова импорта по именам модулей и алиасам
	}
	return nil
}

//По поледнему слову секции импорта вырезает слова для импорта
func (сам *ТСекцияИмпорт) _СловаСекцииРазделить() (ош error) {
	словаИмпорт := make(map[мИнт.ССловоНомерИмпорт]мИнт.ИСлово)
	//Первое слово ИМПОРТ уже отброшено. Разделитель секции тоже не нужен -- пропускаем
	for адр := мИнт.ССловоНомерМодуль(0); адр < сам.словоКонец; адр++ {
		словаИмпорт[мИнт.ССловоНомерИмпорт(адр)] = сам.СловаМодуля()[адр]
		delete(сам.СловаМодуля(), адр)
	}
	//Удалить разделитель из слов модуля
	delete(сам.СловаМодуля(), сам.словоКонец)
	сам.словаИмпорт = словаИмпорт
	//Отладочный вывод для понять, что получилось
	мФмт.Printf("ТСекцияИмпорт._СловаСекцииРазделить(): всего слов секции ИМПОРТ=[%v]\n", len(сам.словаИмпорт))
	//Теперь надо изменить нумерацию слов в секции модуля
	//Получим все номера секции МОДУЛЬ
	номера := make(map[int]мИнт.ССловоНомерМодуль)
	ном := 0
	for адр := range сам.СловаМодуля() {
		номера[ном] = адр
		ном++
	}
	//Теперь перенумеруем слова модуля
	словаМодуля := make(map[мИнт.ССловоНомерМодуль]мИнт.ИСлово)
	for адр := 0; адр < len(номера); адр++ {
		словаМодуля[мИнт.ССловоНомерМодуль(адр)] = сам.СловаМодуля()[номера[(адр)]]
	}
	if ош = сам.СловаУст(словаМодуля); ош != nil {
		return мФмт.Errorf("ТСекцияИмпорт._СловаСекцииРазделить(): ошибка при обрезке слов модуля в секции импорта\n\t%v", ош)
	}
	//Отладочный вывод для понять, что получилось
	мФмт.Printf("ТСекцияИмпорт._СловаСекцииРазделить(): всего слов секции МОДУЛЬ=[%v]\n", len(сам.СловаМодуля()))
	return nil
}

func (сам *ТСекцияИмпорт) _ЕслиИмпортОдин() (ош error) {
	мКонс.Конс.Отладить("ТСекцияИмпорт._ЕслиИмпортОдин()")
	счётИмпорт := 0
	словоНом := мИнт.ССловоНомерМодуль(0)
	словаМодуляВсего := len(сам.СловаМодуля())
	for словоНом < мИнт.ССловоНомерМодуль(словаМодуляВсего) {
		слово := сам.СловаМодуля()[словоНом]
		словоНом++
		for индекс := range мСлово.КсИмпорт {
			стрИмпорт := слово.Слово()
			if стрИмпорт == мСлово.КсИмпорт[индекс] {
				счётИмпорт++
			}
			if счётИмпорт > 1 {
				стрИсх := слово.Строка()
				ош = мФмт.Errorf("ТСекцияИмпорт._ЕслиИмпортОдин(): IMPORT два раза в одном модуле запрещён\n\t%v", стрИсх)
				return ош
			}
		}
	}

	return nil
}

//Проверяет первое ключевое слово IMPORT
func (сам *ТСекцияИмпорт) _ЕслиИмпорт() (рез bool, ош error) {
	//Проверить наличие слова IMPORT
	словоИМПОРТ := сам.СловаМодуля()[0]
	окИмп, ош := мКлюч.Ключи.Проверить("IMPORT", мИнт.СКлюч(словоИМПОРТ.Слово()))
	if ош != nil {
		return false, мФмт.Errorf("ТСекцияИмпорт._ЕслиИмпорт(): ошибка пи поиске ключевого слова IMPORT\n\t%v", ош)
	}
	if !окИмп {
		return false, nil
	}
	//Слово IMPORT найдено
	слова, ош := мИнт.СловаМодуляОбрезать(сам.СловаМодуля())
	if ош != nil {
		return false, мФмт.Errorf("ТСекцияИмпорт._ЕслиИмпорт(): ошибка при обрезке слов\n\t%v", ош)
	}
	сам.СловаУст(слова)
	return true, nil
}

//Ищет разделитель в секции импорта
func (сам *ТСекцияИмпорт) _ЕслиИмпортОграничен() (ош error) {
	_КонецСекции := func(слово мИнт.ИСлово) bool {
		стр := слово.Слово()
		return стр == ";"
	}
	for счётСловоИмпорт := мИнт.ССловоНомерМодуль(0); int(счётСловоИмпорт) < len(сам.СловаМодуля()); счётСловоИмпорт++ {
		слово := сам.СловаМодуля()[счётСловоИмпорт]
		if _КонецСекции(слово) {
			сам.словоКонец = счётСловоИмпорт
			return nil
		}
	}
	return мФмт.Errorf("ТуИмпорт._ЕслиИмпортОграничен(): секция импорта ничем не ограничена\n")
}

// СловаИмпорт -- Возвращает слова импорта
func (сам *ТСекцияИмпорт) СловаИмпорт() (слова map[мИнт.ССловоНомерИмпорт]мИнт.ИСлово) {
	return сам.словаИмпорт
}
