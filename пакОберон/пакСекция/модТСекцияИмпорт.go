package пакСекция

// модИмпорт

/*
	Модуль предоставляет тип для анализа секции импорта
*/

import (
	мИнт "../пакИнтерфейсы"
	пакКонс "../пакКонсоль"
	пакСлово "../пакСлово"
	мФмт "fmt"
)

//ТСекцияИмпорт -- тип выделяети хранит слова импорта
type ТСекцияИмпорт struct {
	*ТСекция
	словаИмпорт map[мИнт.ССловоНомерИмпорт]мИнт.ИСлово
}

//ИмпортНов -- Создаёт и возвращает новый экземпляр для выделения слов импорта модуля
func ИмпортНов() (импорт *ТСекцияИмпорт, ош error) {
	пакКонс.Конс.Отладить("ИмпортНов()")
	секция, ош := СекцияНов("ИМПОРТ")
	if ош != nil {
		return nil, мФмт.Errorf("ИмпортНов(): ошибка при создании секции импорта\n\t%v", ош)
	}
	импорт = &ТСекцияИмпорт{
		ТСекция: секция,
	}
	импорт.словаИмпорт=make(map[мИнт.ССловоНомерИмпорт]мИнт.ИСлово)
	return импорт, ош
}

//Обработать -- главная функция обработки секции импорт
func (сам *ТСекцияИмпорт) Обработать(пСловаМодуля map[мИнт.ССловоНомерМодуль]мИнт.ИСлово) (ош error) {
	пакКонс.Конс.Отладить("ТСекцияИмпорт.Обработать()")
	сам.СловаУст(пСловаМодуля)
	if сам._ЕслиИмпорт() {
		if ош := сам._ЕслиИмпортОдин(); ош != nil {
			ош = мФмт.Errorf("ТСекцияИмпорт.Обработать(): ошибка при проверке одной секции импорт\n\t%v", ош)
			return ош
		}
		if ош := сам._ЕслиИмпортОграничен(); ош == nil {
			сам._СловаСекцииРазделить()
			return nil
		}
		ош = мФмт.Errorf("ТСекцияИмпорт.Обработать(): ошибка при проверке ограничения секции импорта\n\t%v", ош)
		return ош
	}
	panic("ТСекцияИмпорт.Обработать(): 1 -- до этого места код дойти не должен")
}

func (сам *ТСекцияИмпорт)_СловаСекцииРазделить(){

}

func (сам *ТСекцияИмпорт) _ЕслиИмпортОдин() (ош error) {
	пакКонс.Конс.Отладить("ТСекцияИмпорт._ЕслиИмпортОдин()")
	счётИмпорт := 0
	словоНом := мИнт.ССловоНомерМодуль(0)
	словаМодуляВсего := len(сам.СловаМодуля())
	for словоНом < мИнт.ССловоНомерМодуль(словаМодуляВсего) {
		слово := сам.СловаМодуля()[словоНом]
		словоНом++
		for индекс := range пакСлово.КсИмпорт {
			стрИмпорт := слово.Слово()
			if стрИмпорт == пакСлово.КсИмпорт[индекс] {
				счётИмпорт++
			}
			if счётИмпорт > 1 {
				стрИсх := слово.Строка()
				ош = мФмт.Errorf("ТСекцияИмпорт._ЕслиИмпортОдин(): IMPORT два раза в одном модуле запрещён\n\t%v", стрИсх)
				return ош
			}
		}
	}

	return nil
}
func (сам *ТСекцияИмпорт) _ЕслиИмпорт() (рез bool) {
	слово := сам.СловаМодуля()[0]
	//Цикл по словарю слова IMPORT
	for _, слИмпорт := range пакСлово.КсИмпорт {
		//Проверка на все возможные значения
		стрИмпорт := слово.Слово()
		if стрИмпорт == слИмпорт {
			рез = true
			if слова, ош := мИнт.СловаМодуляОбрезать(сам.СловаМодуля()); ош != nil {
				panic(мФмт.Errorf("ТСекцияИмпорт._ЕслиИмпорт(): ошибка при обрезке слов\n\t%v", ош))
			} else {
				сам.СловаУст(слова)
			}

		}
	}
	return рез
}

func (сам *ТСекцияИмпорт) _ЕслиИмпортОграничен() (ош error) {
	Дальше := func(слово мИнт.ИСлово) bool {
		стр := слово.Строка()
		return стр != ";"
	}
	цСловоНомерМодуль := мИнт.ССловоНомерМодуль(0)
	слово := сам.СловаМодуля()[0]
	for Дальше(слово) && (int(цСловоНомерМодуль) < len(сам.СловаМодуля())) {
		цСловоНомерМодуль++
		слово = сам.СловаМодуля()[цСловоНомерМодуль]
	}
	if Дальше(слово) {
		ош = мФмт.Errorf("ТуИмпорт._ЕслиИмпортОграничен(): секция импорта ничем не ограничена")
		return ош
	}
	сам._КонецУст()
	return ош
}

func(сам *ТСекцияИмпорт)_КонецУст(){

}


// СловаИмпорт -- Возвращает слова импорта
func (сам *ТСекцияИмпорт) СловаИмпорт() (слова map[мИнт.ССловоНомерИмпорт]мИнт.ИСлово) {
	return сам.словаИмпорт
}

