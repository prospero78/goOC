package пакСлово

/*
	Предоставляет тип слова для построения AST.
	Слово -- кусочек текста в исходнике.
	Обладает несколькими свойствами:
	1. Группа литер (само слово, может быть из одной литеры)
	2. Координаты.
	3. Строка, в которой он находится.
*/

import (
	мФмт "fmt"

	//мКонс "../../../пакКонсоль"
	мКоорд "github.com/prospero78/goOC/пакОберон/пакКоорд"
	мЛит "github.com/prospero78/goOC/пакОберон/пакЛитера"
	мИс "github.com/prospero78/goOC/пакОберон/пакПулИсхСтроки/пакИсхСтрока"
	мИсс "github.com/prospero78/goOC/пакОберон/пакПулИсхСтроки/пакИсхСтрока/пакИсхСтрокаСтр"
	мРод "github.com/prospero78/goOC/пакОберон/пакСлово/пакСловоРод"
)

//ССлово -- специальный строковый тип для хранения слова исходника
type ССлово string

//ССловоНомер -- специальный целочисленный тип для хранения номера слова исходника
type ССловоНомер int

//ИСлово -- интерфейс для типа слова
type ИСлово interface {
	//ЛитУст(мЛит.СЛит) error
	ЕслиИмяСтрого() bool
	Слово() ССлово
	Строка() мИсс.СИсхСтрокаСтр
	Номер() ССловоНомер
}

//тСлово -- тип хранящий слово со всеми необходимыми атрибутами
type тСлово struct {
	стрИсх   мИс.ИИсхСтрока // Строка исходника
	стрСлово ССлово         // Строка слова
	род      мРод.ИСловоРод // род слова
	Коорд    мКоорд.ИКоорд  // Координаты слова в исходном тексте
	номер    ССловоНомер    // Текущий номер слова
	лит      мЛит.ИЛит      //текущая литера
}

var словВсего = ССловоНомер(0)

//СловоНов -- возвращает ссылку на новый ИСлово
func СловоНов(пКоорд мКоорд.ИКоорд, пСлово ССлово, пСтрИсх мИс.ИИсхСтрока) (слово ИСлово, ош error) {
	if len(пСлово) == 0 {
		return nil, мФмт.Errorf("СловоНовое(): строка имеет длину 0\n")
	}
	_слово := &тСлово{
		стрСлово: пСлово,
		стрИсх:   пСтрИсх,
		Коорд:    пКоорд,
		номер:    словВсего,
	}

	if _слово.лит, ош = мЛит.ЛитераНов(); ош != nil {
		return nil, мФмт.Errorf("СловоНовое(): ОШИБКА при создании объекта литеры\n\t%v", ош)
	}
	if _слово.род, ош = мРод.СловоРодНов(мРод.ССловоРод(_слово.Слово())); ош != nil {
		return nil, мФмт.Errorf("СловоНовое(): ОШИБКА при создании рода слова\n\t%v", ош)
	}
	словВсего++
	return _слово, nil
}

//Род -- возвращает род слова
func (сам *тСлово) Род() мРод.СРод {
	return сам.род.Получ()
}

//Номер -- возвращает номер слова в исходнике
func (сам *тСлово) Номер() ССловоНомер {
	return сам.номер
}

// ЕслиПерваяБуква -- проверяет наличие первой буквы в строке
func (сам *тСлово) ЕслиПерваяБуква(пСтрока ССлово) (бРез bool, ош error) {
	руна := []rune(пСтрока)
	стрЛит := мЛит.СЛит(руна[0])
	if ош = сам.лит.Уст(стрЛит); ош != nil {
		return false, мФмт.Errorf("тСлово.ЕслиПерваяБуква(): ОШИБКА в установке литеры\n\t%v", ош)
	}
	//пакКонс.Конс.Печать("пакСлово.ЕслиПерваяБуква(): лит=" + стрЛит)
	if сам.лит.ЕслиБуква() {
		return true, nil
	}
	return false, nil
}

//ЕслиЧисло -- проверяет, что слово число
func (сам *тСлово) ЕслиЧисло(пСлово ССлово) (бРез bool, ош error) {
	for _, лит := range пСлово {
		if ош = сам.лит.Уст(мЛит.СЛит(лит)); ош != nil {
			return false, мФмт.Errorf("тСлово.ЕслиЧисло(): ОШИБКА в установке литеры\n\t%v", ош)
		}
		if !сам.лит.ЕслиЦифра() {
			return false, nil
		}
	}
	return true, nil
}

// Проверяет, что строка не находится в ключевых словах
func (сам *тСлово) _ЕслиКлючевоеСлово() (бРез bool) {
	бРез = false // По умолчанию -- имя разрешено
	for _, группа := range КлючСлово {
		for _, ключевое := range группа {
			if сам.стрСлово == ключевое {
				бРез = true
				return бРез
			}
		}
	}
	return бРез
}

// Проверяет, что литера не находится в списке запрещённых (для имён сущностей)
func _ЕслиЛитЗапрещена(пЛит rune) (бРез bool) {
	//стрЗапрет:=[]rune("")
	стрЗапрет := []rune("\"~`!@$%^&*()-=+{}[]|\\<,>?/№;:\t\n'\r ")
	for _, лит := range стрЗапрет {
		if пЛит == лит {
			бРез = true
			return бРез
		}
	}
	return бРез
}

// ЕслиИмяСтрого -- проверяет, что строка обладает строгим соответствием, чтобы быть именем сущности
func (сам *тСлово) ЕслиИмяСтрого() bool {
	// имя сущности должно начинаться либо с "_", либо с буквы
	строка := []rune(сам.стрСлово)
	лит := мЛит.СЛит(строка[0])
	if ош := сам.лит.Уст(лит); ош != nil {
		panic(мФмт.Sprintf("тСлово.ЕслиИмяСтрого(): ОШИБКА при присвоении литеры\n\t%v", ош))
	}
	if лит == "_" || сам.лит.ЕслиБуква() {
		if лит != "_" && сам._ЕслиКлючевоеСлово() {
			return false
		}
		for _, лит := range строка {
			// Точка в имени -- допустимо, но здесь её не будет.
			if _ЕслиЛитЗапрещена(лит) {
				//
				return false
			}
		}
	}
	return true
}

//Слово -- возвращает слово, которое хранит тип
func (сам *тСлово) Слово() ССлово {
	return сам.стрСлово
}

// Строка -- возвращает строку исходника, содержащую подстроку
func (сам *тСлово) Строка() мИсс.СИсхСтрокаСтр {
	return сам.стрИсх.Строка()
}

func (сам *тСлово) String() string {
	стрВых := мФмт.Sprintf("%v: %v [%v]", сам.Коорд, сам.стрИсх, сам.стрСлово)
	return стрВых
}
