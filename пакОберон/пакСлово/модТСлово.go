package пакСлово

/*
	Предоставляет тип слова для построения AST.
	Слово -- кусочек текста в исходнике.
	Обладает несколькими свойствами:
	1. Группа литер (само слово, может быть из одной литеры)
	2. Координаты.
	3. Строка, в которой он находится.
*/

import (
	//мКонс "../../../пакКонсоль"
	мИнт "../пакИнтерфейсы"
	мЛит "../пакЛитера"
	мФмт "fmt"
	мСтр "strings"
)

var словВсего = мИнт.ССловоНомер(0)

//ТСлово -- тип хранящий слово со всеми необходимыми атрибутами
type ТСлово struct {
	стрИсх   мИнт.СИсхСтрока  // Строка исходника
	стрСлово мИнт.ССлово      // Строка слова
	род      мИнт.ССловоРод   // род слова
	Коорд    мИнт.ИКоорд      // Координаты слова в исходном тексте
	номер    мИнт.ССловоНомер // Текущий номер слова
	лит      мИнт.ИЛит        //текущая литера
}

//СловоНов -- возвращает ссылку на новый ТСлово
func СловоНов(пКоорд мИнт.ИКоорд, пСлово мИнт.ССлово, пСтрИсх мИнт.СИсхСтрока) (слово *ТСлово, ош error) {
	родПроверить := func(сам *ТСлово) (род мИнт.ССловоРод, ош error) { //Устанавливает род слова.
		род = -1
		if ош = слово.лит.Уст("_"); ош != nil {
			return -1, мФмт.Errorf("СловоНовое(): ошибка при присвоении объекта литеры\n\t%v", ош)
		}
		сл := string(пСлово)
		if сл == ";" {
			род = КТочкаЗапятая
		} else if сл == "," {
			род = КЗапятая
		} else if сл == "+" {
			род = КПлюс
		} else if сл == "-" {
			род = КМинус
		} else if сл == "/" {
			род = КДеление
		} else if сл == "(" {
			род = КСкобкаОткрКругл
		} else if сл == "(*" {
			род = ККомментНачать
		} else if сл == ")" {
			род = КСкобкаЗакрКругл
		} else if сл == "*)" {
			род = ККомментЗакончить
		} else if сл == "*" {
			род = КУмножить
		} else if сл == ":=" {
			род = КПрисвоить
		} else if сл == ":" {
			род = КОпределить
		} else if сл == "=" {
			род = КРавно
		} else if сл == "." {
			род = КТочка
		}
		слНач := пСлово[0]
		слКон := пСлово[len(пСлово)-1]
		if слНач == '"' && слКон == '"' {
			род = КСтрока
		}
		префикс := мСтр.HasPrefix(string(слово.лит.Лит()), "_")
		первБуква, ош := слово.ЕслиПерваяБуква(пСлово)
		if ош != nil {
			return -1, мФмт.Errorf("СловоНов().РодПроверить(): ошибка при проверки литеры\n\t%v", ош)
		}
		if префикс || первБуква {
			род = КИмя
		}
		слово.лит.Уст(мИнт.СЛит(пСлово[0]))
		if слово.лит.ЕслиЦифра() {
			род = КЧисло
		} else {
			ош = мФмт.Errorf("СловоНов(): не могу классифицировать строку, строка=" + string(пСлово))
		}
		if род != -1 {
			return мИнт.ССловоРод(род), nil
		}
		//сам.Род = пакТипы.ТРод(род)
		return мИнт.ССловоРод(род), nil
	}
	if len(пСлово) == 0 {
		return nil, мФмт.Errorf("СловоНовое(): строка имеет длину 0\n")
	}
	слово = &ТСлово{
		стрСлово: пСлово,
		стрИсх:   пСтрИсх,
		Коорд:    пКоорд,
		номер:    словВсего,
	}
	if слово.лит, ош = мЛит.ЛитераНов(); ош != nil {
		return nil, мФмт.Errorf("СловоНовое(): ошибка при создании объекта литеры\n\t%v", ош)
	}
	if слово.род, ош = родПроверить(слово); ош != nil {
		return nil, мФмт.Errorf("СловоНовое(): при вызове родПроверить()\n\t%v", ош)
	}
	словВсего++
	return слово, nil
}

//Род -- возвращает род слова
func (сам *ТСлово) Род() int {
	return int(сам.род)
}

//Номер -- возвращает номер слова в исходнике
func (сам *ТСлово) Номер() мИнт.ССловоНомер {
	return сам.номер
}

// ЕслиПерваяБуква -- проверяет наличие первой буквы в строке
func (сам *ТСлово) ЕслиПерваяБуква(пСтрока мИнт.ССлово) (бРез bool, ош error) {
	руна := []rune(пСтрока)
	стрЛит := мИнт.СЛит(руна[0])
	if ош = сам.лит.Уст(стрЛит); ош != nil {
		return false, мФмт.Errorf("ТСлово.ЕслиПерваяБуква(): ошибка в установке литеры\n\t%v", ош)
	}
	//пакКонс.Конс.Печать("пакСлово.ЕслиПерваяБуква(): лит=" + стрЛит)
	if сам.лит.ЕслиБуква() {
		return true, nil
	}
	return false, nil
}

//ЕслиЧисло -- проверяет, что слово число
func (сам *ТСлово) ЕслиЧисло(пСлово мИнт.ССлово) (бРез bool, ош error) {
	for _, лит := range пСлово {
		if ош = сам.лит.Уст(мИнт.СЛит(лит)); ош != nil {
			return false, мФмт.Errorf("ТСлово.ЕслиЧисло(): ошибка в установке литеры\n\t%v", ош)
		}
		if !сам.лит.ЕслиЦифра() {
			return false, nil
		}
	}
	return true, nil
}

// Проверяет, что строка не находится в ключевых словах
func (сам *ТСлово) _ЕслиКлючевоеСлово() (бРез bool) {
	бРез = false // По умолчанию -- имя разрешено
	for _, группа := range КлючСлово {
		for _, ключевое := range группа {
			if сам.стрСлово == ключевое {
				бРез = true
				return бРез
			}
		}
	}
	return бРез
}

// Проверяет, что литера не находится в списке запрещённых (для имён сущностей)
func _ЕслиЛитЗапрещена(пЛит rune) (бРез bool) {
	//стрЗапрет:=[]rune("")
	стрЗапрет := []rune("\"~`!@$%^&*()-=+{}[]|\\<,>?/№;:\t\n'\r ")
	for _, лит := range стрЗапрет {
		if пЛит == лит {
			бРез = true
			return бРез
		}
	}
	return бРез
}

// ЕслиИмяСтрого -- проверяет, что строка обладает строгим соответствием, чтобы быть именем сущности
func (сам *ТСлово) ЕслиИмяСтрого() bool {
	// имя сущности должно начинаться либо с "_", либо с буквы
	строка := []rune(сам.стрСлово)
	лит := мИнт.СЛит(строка[0])
	if ош := сам.лит.Уст(лит); ош != nil {
		panic(мФмт.Sprintf("ТСлово.ЕслиИмяСтрого(): ошибка при присвоении литеры\n\t%v", ош))
	}
	if лит == "_" || сам.лит.ЕслиБуква() {
		if лит != "_" && сам._ЕслиКлючевоеСлово() {
			return false
		}
		for _, лит := range строка {
			// Точка в имени -- допустимо, но здесь её не будет.
			if _ЕслиЛитЗапрещена(лит) {
				//
				return false
			}
		}
	}
	return true
}

//Слово -- возвращает слово, которое хранит тип
func (сам *ТСлово) Слово() мИнт.ССлово {
	return сам.стрСлово
}

// Строка -- возвращает строку исходника, содержащую подстроку
func (сам *ТСлово) Строка() мИнт.СИсхСтрока {
	return сам.стрИсх
}

func (сам *ТСлово) String() string {
	стрВых := мФмт.Sprintf("%v: %v [%v]", сам.Коорд.Стр(), сам.стрИсх, сам.стрСлово)
	return стрВых
}
