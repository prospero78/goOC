package пакСлово

/*
	Предоставляет тип слова для построения AST.
	Слово -- кусочек текста в исходнике.
	Обладает несколькими свойствами:
	1. Группа литер (само слово, может быть из одной литеры)
	2. Координаты.
	3. Строка, в которой он находится.
*/

import (
	//мКонс "../../../пакКонсоль"
	мАбс "../пакАбстракция"
	мФмт "fmt"
	мСтр "strings"
)

var словВсего = мАбс.ССловоНомер(0)

//ТСлово -- тип хранящий слово со всеми необходимыми атрибутами
type ТСлово struct {
	стрИсх   мАбс.СИсхСтрока  // Строка исходника
	стрСлово мАбс.ССлово      // Строка слова
	род      мАбс.ССловоРод   // род слова
	Коорд    мАбс.АКоорд      // Координаты слова в исходном тексте
	номер    мАбс.ССловоНомер // Текущий номер слова
}

//СловоНов -- возвращает ссылку на новый ТСлово
func СловоНов(пКоорд мАбс.АКоорд, пСлово мАбс.ССлово, пСтрИсх мАбс.СИсхСтрока) (слово *ТСлово, ош error) {
	родПроверить := func(сам *ТСлово) (род мАбс.ССловоРод, ош error) { //Устанавливает род слова.
		ЕслиЦифра := func(пЛит мАбс.СЛит) bool {
			рез, ош := Цифра.ЕслиЦифра(пЛит)
			if ош != nil {
				panic(мФмт.Errorf("СловоНов(): ошибка при проверке литеры [%v]\n\t%v", пЛит, ош))
			}
			return рез
		}
		род = -1
		switch {
		case string(пСлово) == ";":
			род = КТочкаЗапятая
		case string(пСлово) == ",":
			род = КЗапятая
		case string(пСлово) == "+":
			род = КПлюс
		case string(пСлово) == "-":
			род = КМинус
		case string(пСлово) == "/":
			род = КДеление
		case string(пСлово) == "(":
			род = КСкобкаОткрКругл
		case string(пСлово) == "(*":
			род = ККомментНачать
		case string(пСлово) == ")":
			род = КСкобкаЗакрКругл
		case string(пСлово) == "*)":
			род = ККомментЗакончить
		case string(пСлово) == "*":
			род = КУмножить
		case string(пСлово) == ":=":
			род = КПрисвоить
		case string(пСлово) == ":":
			род = КОпределить
		case мСтр.HasPrefix(string(пСлово), "_") || ЕслиПерваяБуква(пСлово):
			род = КИмя
		case ЕслиЦифра(мАбс.СЛит(пСлово[0])):
			род = КЧисло
		case string(пСлово) == "=":
			род = КРавно
		case string(пСлово) == ".":
			род = КТочка
		case пСлово[0] == '"' && пСлово[len(пСлово)-1] == '"':
			род = КСтрока
		default:
			ош = мФмт.Errorf("СловоНов(): не могу классифицировать строку, строка=" + string(пСлово))
		}
		//сам.Род = пакТипы.ТРод(род)
		return мАбс.ССловоРод(род), nil
	}
	if len(пСлово) == 0 {
		return nil, мФмт.Errorf("СловоНовое(): строка имеет длину 0\n")
	}
	род, ош := родПроверить(слово)
	if ош != nil {
		return nil, мФмт.Errorf("СловоНовое(): при вызове родПроверить()\n\t%v", ош)
	}
	словВсего++
	слово = &ТСлово{
		стрСлово: пСлово,
		стрИсх:   пСтрИсх,
		Коорд:    пКоорд,
		род:      род,
		номер:    словВсего,
	}
	return слово, nil
}

//Род -- возвращает род слова
func (сам *ТСлово) Род() int {
	return int(сам.род)
}

//Номер -- возвращает номер слова в исходнике
func (сам *ТСлово) Номер() мАбс.ССловоНомер {
	return сам.номер
}

// ЕслиПерваяБуква -- проверяет наличие первой буквы в строке
func ЕслиПерваяБуква(пСтрока мАбс.ССлово) (бРез bool) {
	руна := []rune(пСтрока)
	стрЛит := мАбс.СЛит(руна[0])
	//пакКонс.Конс.Печать("пакСлово.ЕслиПерваяБуква(): лит=" + стрЛит)
	if ЕслиБуква(стрЛит) {
		бРез = true
	}
	return бРез
}

// ЕслиБуква -- проверяет наличие буквы в литере
func ЕслиБуква(пЛит мАбс.СЛит) (бРез bool) {
	if мСтр.Contains(стрБуквыВсе, string(пЛит)) {
		бРез = true
	}
	return бРез
}

//ЕслиЦифра -- проверяет, что литера цифра
func ЕслиЦифра(пЛит мАбс.СЛит) bool {
	if мСтр.Contains(стрЦифры, string(пЛит)) {
		return true
	}
	return false
}

//ЕслиЧисло -- проверяет, что слово число
func (сам *ТСлово) ЕслиЧисло(пСлово мАбс.ССлово) bool {
	for _, лит := range пСлово {
		if !мСтр.Contains(стрЦифры, string(лит)) {
			return false
		}
	}
	return true
}

// Проверяет, что строка не находится в ключевых словах
func (сам *ТСлово) _ЕслиКлючевоеСлово() (бРез bool) {
	бРез = false // По умолчанию -- имя разрешено
	for _, группа := range КлючСлово {
		for _, ключевое := range группа {
			if сам.стрСлово == ключевое {
				бРез = true
				return бРез
			}
		}
	}
	return бРез
}

// Проверяет, что литера не находится в списке запрещённых (для имён сущностей)
func _ЕслиЛитЗапрещена(пЛит rune) (бРез bool) {
	//стрЗапрет:=[]rune("")
	стрЗапрет := []rune("\"~`!@$%^&*()-=+{}[]|\\<,>?/№;:\t\n'\r ")
	for _, лит := range стрЗапрет {
		if пЛит == лит {
			бРез = true
			return бРез
		}
	}
	return бРез
}

// ЕслиИмяСтрого -- проверяет, что строка обладает строгим соответствием, чтобы быть именем сущности
func (сам *ТСлово) ЕслиИмяСтрого() (бРез bool) {
	// имя сущности должно начинаться либо с "_", либо с буквы
	бРез = true // По умолчанию -- имя строго соответствует
	строка := []rune(сам.стрСлово)
	лит := мАбс.СЛит(строка[0])
	if лит == "_" || ЕслиБуква(лит) {
		if лит != "_" && сам._ЕслиКлючевоеСлово() {
			бРез = false
			return бРез
		}
		for _, лит := range строка {
			// Точка в имени -- допустимо, но здесь её не будет.
			if _ЕслиЛитЗапрещена(лит) {
				//
				бРез = false
				return бРез
			}
		}
	}
	return бРез
}

//Слово -- возвращает слово, которое хранит тип
func (сам *ТСлово) Слово() мАбс.ССлово {
	return сам.стрСлово
}

// Строка -- возвращает строку исходника, содержащую подстроку
func (сам *ТСлово) Строка() мАбс.СИсхСтрока {
	return сам.стрИсх
}
